(self.webpackChunkangular_template_for_threejs=self.webpackChunkangular_template_for_threejs||[]).push([[8778],{"./projects/atft/src/lib/animation/animation.service.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Y:()=>AnimationService});var tslib__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./projects/atft/src/lib/renderer/renderer.service.ts");let AnimationService=class AnimationService{constructor(rendererService){this.rendererService=rendererService,this.animate=new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter,this.enabled=!1,this.animationStep=this.animationStep.bind(this)}start(){this.enabled||(this.enabled=!0,this.animationStep())}stop(){this.enabled&&(this.enabled=!1)}animationStep(){this.enabled&&this.animate.observers&&(requestAnimationFrame(this.animationStep),this.animate.observers.length>0&&(this.animate.emit(),this.rendererService.render()))}static#_=this.ctorParameters=()=>[{type:_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_1__.y}]};AnimationService=(0,tslib__WEBPACK_IMPORTED_MODULE_2__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable)()],AnimationService)},"./projects/atft/src/lib/atft.module.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{p:()=>AtftModule});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),three_module=__webpack_require__("./node_modules/three/build/three.module.js"),renderer_service=__webpack_require__("./projects/atft/src/lib/renderer/renderer.service.ts"),provide_parent=__webpack_require__("./projects/atft/src/lib/util/provide-parent.ts");let AbstractCamera=class AbstractCamera{constructor(rendererService){this.rendererService=rendererService,this.zAxisUp=!1}ngOnInit(){this.createCamera(),this.layer?this.camera.layers.enable(this.layer):this.camera.layers.enableAll(),this.applyZAxisUp(),this.applyPosition(),this.rendererService.setCamera(this)}ngOnChanges(changes){let mustRerender=!1;["positionX","positionY","positionZ"].some((propName=>propName in changes))&&(this.applyPosition(),mustRerender=!0),mustRerender&&this.rendererService.render()}applyPosition(){this.camera&&this.camera.position.set(this.positionX||0,this.positionY||0,this.positionZ||0)}applyZAxisUp(){this.camera&&this.zAxisUp&&this.camera.up.set(0,0,1)}static#_=this.ctorParameters=()=>[{type:renderer_service.y}];static#_2=this.propDecorators={positionX:[{type:core.Input}],positionY:[{type:core.Input}],positionZ:[{type:core.Input}],zAxisUp:[{type:core.Input}],layer:[{type:core.Input}]}};AbstractCamera=(0,tslib_es6.gn)([(0,core.Directive)()],AbstractCamera);let PerspectiveCameraComponent=class PerspectiveCameraComponent extends AbstractCamera{constructor(rendererService){super(rendererService),this.rendererService=rendererService}createCamera(){this.camera=new three_module.cPb(this.fov,void 0,this.near,this.far)}updateAspectRatio(aspect){this.camera.aspect=aspect,this.camera.updateProjectionMatrix()}static#_=this.ctorParameters=()=>[{type:renderer_service.y}];static#_2=this.propDecorators={fov:[{type:core.Input}],near:[{type:core.Input}],far:[{type:core.Input}]}};PerspectiveCameraComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-perspective-camera",providers:[(0,provide_parent.T)(PerspectiveCameraComponent,AbstractCamera)],template:"<ng-content></ng-content>"})],PerspectiveCameraComponent);let OrthographicCameraComponent=class OrthographicCameraComponent extends AbstractCamera{constructor(rendererService){super(rendererService),this.rendererService=rendererService,this.zoom=4}createCamera(){this.camera=new three_module.iKG(window.innerWidth/-2,window.innerWidth/2,window.innerHeight/-2,window.innerHeight/2,.1,1e4),this.updateZoom()}ngOnChanges(changes){if(!this.camera)return;let mustRerender=!1;["zoom"].some((propName=>propName in changes))&&(this.updateZoom(),mustRerender=!0),mustRerender&&this.rendererService.render()}updateZoom(){this.camera.zoom=this.zoom}updateAspectRatio(aspect){this.camera.left=-1e3*aspect/2,this.camera.right=1e3*aspect/2,this.camera.top=500,this.camera.bottom=-500,this.camera.updateProjectionMatrix(),this.camera.lookAt(new three_module.Pa4(0,0,0))}static#_=this.ctorParameters=()=>[{type:renderer_service.y}];static#_2=this.propDecorators={zoom:[{type:core.Input}]}};OrthographicCameraComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-orthographic-camera",providers:[(0,provide_parent.T)(OrthographicCameraComponent,AbstractCamera)],template:"<ng-content></ng-content>"})],OrthographicCameraComponent);let AtftCameraModule=class AtftCameraModule{};AtftCameraModule=(0,tslib_es6.gn)([(0,core.NgModule)({imports:[common.CommonModule],declarations:[PerspectiveCameraComponent,OrthographicCameraComponent],exports:[PerspectiveCameraComponent,OrthographicCameraComponent]})],AtftCameraModule);var line_connector_component=__webpack_require__("./projects/atft/src/lib/object/connector/line-connector.component.ts");let AtftConnectorModule=class AtftConnectorModule{};AtftConnectorModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[line_connector_component.J],imports:[common.CommonModule],exports:[line_connector_component.J]})],AtftConnectorModule);var abstract_object_3d=__webpack_require__("./projects/atft/src/lib/object/abstract-object-3d.ts");let AxesHelperComponent=class AxesHelperComponent extends abstract_object_3d.l{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.size=50}newObject3DInstance(){return new three_module.y8_(this.size)}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={size:[{type:core.Input}]}};AxesHelperComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-axes-helper",providers:[(0,provide_parent.T)(AxesHelperComponent)],template:"<ng-content></ng-content>"})],AxesHelperComponent);var empty_component=__webpack_require__("./projects/atft/src/lib/object/helper/empty.component.ts");let GridHelperComponent=class GridHelperComponent extends abstract_object_3d.l{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent}newObject3DInstance(){return new three_module.VLJ(this.size,this.divisions)}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={size:[{type:core.Input}],divisions:[{type:core.Input}]}};GridHelperComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-grid-helper",providers:[(0,provide_parent.T)(GridHelperComponent)],template:"<ng-content></ng-content>"})],GridHelperComponent);let AtftHelperModule=class AtftHelperModule{};AtftHelperModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[AxesHelperComponent,empty_component.T,GridHelperComponent],imports:[common.CommonModule],exports:[AxesHelperComponent,empty_component.T,GridHelperComponent]})],AtftHelperModule);let PointLightComponent=class PointLightComponent extends abstract_object_3d.l{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.color="#FFFFFF",this.intensity=1,this.distance=500,this.castShadow=!1}newObject3DInstance(){const light=new three_module.cek(this.color,this.intensity,this.distance);return!0===this.castShadow&&(light.castShadow=this.castShadow,light.shadow.mapSize.width=1024,light.shadow.mapSize.height=1024,light.shadow.camera.near=.5,light.shadow.camera.far=500,light.shadow.bias=-.001,light.shadow.radius=1),light}ngOnInit(){super.ngOnInit()}ngAfterViewInit(){super.ngAfterViewInit()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={color:[{type:core.Input}],intensity:[{type:core.Input}],distance:[{type:core.Input}],castShadow:[{type:core.Input}]}};PointLightComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-point-light",providers:[(0,provide_parent.T)(PointLightComponent)],template:"<ng-content></ng-content>"})],PointLightComponent);let HemisphereLightComponent=class HemisphereLightComponent extends abstract_object_3d.l{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.skyColor="#ffffff",this.groundColor="#444444",this.intensity=1}newObject3DInstance(){return new three_module.vmT(this.skyColor,this.groundColor,this.intensity)}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={skyColor:[{type:core.Input}],groundColor:[{type:core.Input}],intensity:[{type:core.Input}]}};HemisphereLightComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-hemisphere-light",providers:[(0,provide_parent.T)(HemisphereLightComponent)],template:"<ng-content></ng-content>"})],HemisphereLightComponent);let DirectionalLightComponent=class DirectionalLightComponent extends abstract_object_3d.l{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.color="#FFFFFF",this.intensity=1,this.target=new three_module.Tme,this.castShadow=!0}newObject3DInstance(){const light=new three_module.Ox3(this.color,this.intensity);return light.target=this.target,!0===this.castShadow&&(light.castShadow=this.castShadow,light.shadow.camera.top=100,light.shadow.camera.bottom=-100,light.shadow.camera.left=-100,light.shadow.camera.right=100,light.shadow.camera.near=.1,light.shadow.camera.far=500,light.shadow.mapSize.set(1024,1024),light.shadow.bias=-.001),light}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={color:[{type:core.Input}],intensity:[{type:core.Input}],target:[{type:core.Input}],castShadow:[{type:core.Input}]}};DirectionalLightComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-directional-light",providers:[(0,provide_parent.T)(DirectionalLightComponent)],template:"<ng-content></ng-content>"})],DirectionalLightComponent);let AmbientLightComponent=class AmbientLightComponent extends abstract_object_3d.l{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.color="#FFFFFF",this.intensity=.8}newObject3DInstance(){const light=new three_module.Mig(this.color);return light.intensity=this.intensity,light}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={color:[{type:core.Input}],intensity:[{type:core.Input}]}};AmbientLightComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-ambient-light",providers:[(0,provide_parent.T)(AmbientLightComponent)],template:"<ng-content></ng-content>"})],AmbientLightComponent);let AtftLightModule=class AtftLightModule{};AtftLightModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[DirectionalLightComponent,HemisphereLightComponent,PointLightComponent,AmbientLightComponent],imports:[common.CommonModule],exports:[DirectionalLightComponent,HemisphereLightComponent,PointLightComponent,AmbientLightComponent]})],AtftLightModule);var asyncToGenerator=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");let AbstractLazyObject3D=class AbstractLazyObject3D extends abstract_object_3d.l{constructor(){super(...arguments),this.parentInitialized=!1}afterInit(){super.afterInit(),this.parentInitialized=!0,this.startLoading()}startLoading(){this.loadLazyObject().then((obj=>{this.lazyObject&&super.getObject().remove(this.lazyObject),this.lazyObject=obj,super.getObject().add(obj),this.rendererService.render(),setTimeout((()=>{this.rendererService.render()}),10)})).catch((err=>{console.error(err)}))}ngOnDestroy(){this.lazyObject&&super.getObject().remove(this.lazyObject)}newObject3DInstance(){return new three_module.Tme}};AbstractLazyObject3D=(0,tslib_es6.gn)([(0,core.Directive)()],AbstractLazyObject3D);let AbstractModelLoader=class AbstractModelLoader extends AbstractLazyObject3D{set model(newModelUrl){this._model=newModelUrl,this.object&&super.startLoading()}get model(){return this._model}static#_=this.propDecorators={model:[{type:core.Input}]}};AbstractModelLoader=(0,tslib_es6.gn)([(0,core.Directive)()],AbstractModelLoader);let ObjectLoaderComponent=class ObjectLoaderComponent extends AbstractModelLoader{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.loader=new three_module.Gql}loadLazyObject(){var _this=this;return(0,asyncToGenerator.Z)((function*(){return new Promise(((resolve,reject)=>{_this.loader.load(_this.model,(model=>{resolve(model)}),void 0,reject)}))}))()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}]};ObjectLoaderComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-object-loader",providers:[(0,provide_parent.T)(ObjectLoaderComponent)],template:"<ng-content></ng-content>"})],ObjectLoaderComponent);var MTLLoader=__webpack_require__("./node_modules/three/examples/jsm/loaders/MTLLoader.js");class AbstractCacheService{constructor(){this.cache=new Map}load(key){var _this=this;return(0,asyncToGenerator.Z)((function*(){const cacheHit=_this.cache.get(key);if(yield cacheHit)return cacheHit||Promise.reject("Failed to get value from cache");{const cacheMiss=_this.getValue(key);return _this.cache.set(key,cacheMiss),cacheMiss}}))()}}var OBJLoader=__webpack_require__("./node_modules/three/examples/jsm/loaders/OBJLoader.js");let ObjLoaderService=class ObjLoaderService extends AbstractCacheService{constructor(){super(...arguments),this.loader=new OBJLoader.L}getValue(key){return new Promise(((resolve,reject)=>{this.loader.load(key,(model=>{resolve(model)}),void 0,reject)}))}setMaterials(materialCreator){this.loader.setMaterials(materialCreator)}};ObjLoaderService=(0,tslib_es6.gn)([(0,core.Injectable)()],ObjLoaderService);let ObjLoaderComponent=class ObjLoaderComponent extends AbstractModelLoader{set texturePath(newTexturePath){this.resourcePath=newTexturePath}constructor(rendererService,parent,objLoader){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.objLoader=objLoader,this.mtlLoader=new MTLLoader.v}loadLazyObject(){var _this=this;return(0,asyncToGenerator.Z)((function*(){if(_this.material){const preloadingStep=new Promise(((resolve,reject)=>{_this.mtlLoader.setResourcePath(_this.resourcePath),_this.mtlLoader.load(_this.material,(materialCreator=>{materialCreator.preload(),_this.objLoader.setMaterials(materialCreator),resolve()}),void 0,reject)}));yield preloadingStep}return(yield _this.objLoader.load(_this.model)).clone()}))()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]},{type:ObjLoaderService}];static#_2=this.propDecorators={material:[{type:core.Input}],texturePath:[{type:core.Input}],resourcePath:[{type:core.Input}]}};ObjLoaderComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-obj-loader",providers:[(0,provide_parent.T)(ObjLoaderComponent)],template:"<ng-content></ng-content>"})],ObjLoaderComponent);var applied_material=__webpack_require__("./projects/atft/src/lib/util/applied-material.ts");function scaleToFit(group,max){const box=function calculateSize(group){const box=(new three_module.ZzF).setFromObject(group);return new three_module.Pa4(box.max.x-box.min.x,box.max.y-box.min.y,box.max.z-box.min.z)}(group),scaleX=max.x/box.x,scaleY=max.y/box.y,scaleZ=max.z/box.z;group.scale.set(scaleX<1?scaleX:1,scaleY<1?scaleY:1,scaleZ<1?scaleZ:1)}function fixCenter(group){const box=(new three_module.ZzF).setFromObject(group);group.translateX(-(box.max.x-box.min.x)/2-box.min.x),group.translateY(-(box.max.y-box.min.y)/2-box.min.y),group.translateZ(-(box.max.z-box.min.z)/2-box.min.z)}class SVGLoader extends three_module.aNw{constructor(manager){super(manager),this.defaultDPI=90,this.defaultUnit="px",this.defs=[],this.defaultDPI=90,this.defaultUnit="px"}load(url,onLoad,onProgress,onError){const scope=this,loader=new three_module.hH6(scope.manager);loader.setPath(scope.path),loader.setRequestHeader(scope.requestHeader),loader.setWithCredentials(scope.withCredentials),loader.load(url,(function(text){try{onLoad(scope.parse(text))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}}),onProgress,onError)}parse(text){const scope=this;function parseArcCommand(path,rx,ry,x_axis_rotation,large_arc_flag,sweep_flag,start,end){if(0==rx||0==ry)return void path.lineTo(end.x,end.y);x_axis_rotation=x_axis_rotation*Math.PI/180,rx=Math.abs(rx),ry=Math.abs(ry);const dx2=(start.x-end.x)/2,dy2=(start.y-end.y)/2,x1p=Math.cos(x_axis_rotation)*dx2+Math.sin(x_axis_rotation)*dy2,y1p=-Math.sin(x_axis_rotation)*dx2+Math.cos(x_axis_rotation)*dy2;let rxs=rx*rx,rys=ry*ry;const x1ps=x1p*x1p,y1ps=y1p*y1p,cr=x1ps/rxs+y1ps/rys;if(cr>1){const s=Math.sqrt(cr);rxs=(rx*=s)*rx,rys=(ry*=s)*ry}const dq=rxs*y1ps+rys*x1ps,pq=(rxs*rys-dq)/dq;let q=Math.sqrt(Math.max(0,pq));large_arc_flag===sweep_flag&&(q=-q);const cxp=q*rx*y1p/ry,cyp=-q*ry*x1p/rx,cx=Math.cos(x_axis_rotation)*cxp-Math.sin(x_axis_rotation)*cyp+(start.x+end.x)/2,cy=Math.sin(x_axis_rotation)*cxp+Math.cos(x_axis_rotation)*cyp+(start.y+end.y)/2,theta=svgAngle(1,0,(x1p-cxp)/rx,(y1p-cyp)/ry),delta=svgAngle((x1p-cxp)/rx,(y1p-cyp)/ry,(-x1p-cxp)/rx,(-y1p-cyp)/ry)%(2*Math.PI);path.currentPath.absellipse(cx,cy,rx,ry,theta,theta+delta,0===sweep_flag,x_axis_rotation)}function svgAngle(ux,uy,vx,vy){const dot=ux*vx+uy*vy,len=Math.sqrt(ux*ux+uy*uy)*Math.sqrt(vx*vx+vy*vy);let ang=Math.acos(Math.max(-1,Math.min(1,dot/len)));return ux*vy-uy*vx<0&&(ang=-ang),ang}function parseStyle(node,style){style=Object.assign({},style);let stylesheetStyles={};if(node.hasAttribute("class")){const classSelectors=node.getAttribute("class").split(/\s/).filter(Boolean).map((i=>i.trim()));for(let i=0;i<classSelectors.length;i++)stylesheetStyles=Object.assign(stylesheetStyles,stylesheets["."+classSelectors[i]])}function addStyle(svgName,jsName,adjustFunction){void 0===adjustFunction&&(adjustFunction=function copy(v){if(v.startsWith("url")){let ref=v.match(/url\(#(.*)\)/);return ref&&ref[1]?scope.defs[ref[1]]:v}return v}),node.hasAttribute(svgName)&&(style[jsName]=adjustFunction(node.getAttribute(svgName))),stylesheetStyles[svgName]&&(style[jsName]=adjustFunction(stylesheetStyles[svgName])),node.style&&""!==node.style[svgName]&&(style[jsName]=adjustFunction(node.style[svgName]))}function clamp(v){return Math.max(0,Math.min(1,parseFloatWithUnits(v)))}function positive(v){return Math.max(0,parseFloatWithUnits(v))}return node.hasAttribute("id")&&(stylesheetStyles=Object.assign(stylesheetStyles,stylesheets["#"+node.getAttribute("id")])),addStyle("fill","fill"),addStyle("fill-opacity","fillOpacity",clamp),addStyle("opacity","opacity",clamp),addStyle("stroke","stroke"),addStyle("stroke-opacity","strokeOpacity",clamp),addStyle("stroke-width","strokeWidth",positive),addStyle("stroke-linejoin","strokeLineJoin"),addStyle("stroke-linecap","strokeLineCap"),addStyle("stroke-miterlimit","strokeMiterLimit",positive),addStyle("visibility","visibility"),style}function getReflection(a,b){return a-(b-a)}function parseFloats(input,flags,stride){if("string"!=typeof input)throw new TypeError("Invalid input: "+typeof input);const RE={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/};let state=0,seenComma=!0,number="",exponent="";const result=[];function throwSyntaxError(current,i,partial){throw new SyntaxError('Unexpected character "'+current+'" at index '+i+".")}function newNumber(){""!==number&&(""===exponent?result.push(Number(number)):result.push(Number(number)*Math.pow(10,Number(exponent)))),number="",exponent=""}let current;const length=input.length;for(let i=0;i<length;i++)if(current=input[i],Array.isArray(flags)&&flags.includes(result.length%stride)&&RE.FLAGS.test(current))state=1,number=current,newNumber();else{if(0===state){if(RE.WHITESPACE.test(current))continue;if(RE.DIGIT.test(current)||RE.SIGN.test(current)){state=1,number=current;continue}if(RE.POINT.test(current)){state=2,number=current;continue}RE.COMMA.test(current)&&(seenComma&&throwSyntaxError(current,i),seenComma=!0)}if(1===state){if(RE.DIGIT.test(current)){number+=current;continue}if(RE.POINT.test(current)){number+=current,state=2;continue}if(RE.EXP.test(current)){state=3;continue}RE.SIGN.test(current)&&1===number.length&&RE.SIGN.test(number[0])&&throwSyntaxError(current,i)}if(2===state){if(RE.DIGIT.test(current)){number+=current;continue}if(RE.EXP.test(current)){state=3;continue}RE.POINT.test(current)&&"."===number[number.length-1]&&throwSyntaxError(current,i)}if(3===state){if(RE.DIGIT.test(current)){exponent+=current;continue}if(RE.SIGN.test(current)){if(""===exponent){exponent+=current;continue}1===exponent.length&&RE.SIGN.test(exponent)&&throwSyntaxError(current,i)}}RE.WHITESPACE.test(current)?(newNumber(),state=0,seenComma=!1):RE.COMMA.test(current)?(newNumber(),state=0,seenComma=!0):RE.SIGN.test(current)?(newNumber(),state=1,number=current):RE.POINT.test(current)?(newNumber(),state=2,number=current):throwSyntaxError(current,i)}return newNumber(),result}const units=["mm","cm","in","pt","pc","px"],unitConversion={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function parseFloatWithUnits(string){let scale,theUnit="px";if("string"==typeof string||string instanceof String)for(let i=0,n=units.length;i<n;i++){const u=units[i];if(string.endsWith(u)){theUnit=u,string=string.substring(0,string.length-u.length);break}}return"px"===theUnit&&"px"!==scope.defaultUnit?scale=unitConversion.in[scope.defaultUnit]/scope.defaultDPI:(scale=unitConversion[theUnit][scope.defaultUnit],scale<0&&(scale=unitConversion[theUnit].in*scope.defaultDPI)),scale*parseFloat(string)}function getTransformScaleX(m){const te=m.elements;return Math.sqrt(te[0]*te[0]+te[1]*te[1])}function getTransformScaleY(m){const te=m.elements;return Math.sqrt(te[3]*te[3]+te[4]*te[4])}const paths=[],stylesheets={},transformStack=[],tempTransform0=new three_module.Vkp,tempTransform1=new three_module.Vkp,tempTransform2=new three_module.Vkp,tempTransform3=new three_module.Vkp,tempV2=new three_module.FM8,tempV3=new three_module.Pa4,currentTransform=new three_module.Vkp,xml=(new DOMParser).parseFromString(text,"image/svg+xml");!function parseNode(node,style){if(1!==node.nodeType)return;const transform=function getNodeTransform(node){if(!(node.hasAttribute("transform")||"use"===node.nodeName&&(node.hasAttribute("x")||node.hasAttribute("y"))))return null;const transform=function parseNodeTransform(node){const transform=new three_module.Vkp,currentTransform=tempTransform0;if("use"===node.nodeName&&(node.hasAttribute("x")||node.hasAttribute("y"))){const tx=parseFloatWithUnits(node.getAttribute("x")),ty=parseFloatWithUnits(node.getAttribute("y"));transform.translate(tx,ty)}if(node.hasAttribute("transform")){const transformsTexts=node.getAttribute("transform").split(")");for(let tIndex=transformsTexts.length-1;tIndex>=0;tIndex--){const transformText=transformsTexts[tIndex].trim();if(""===transformText)continue;const openParPos=transformText.indexOf("("),closeParPos=transformText.length;if(openParPos>0&&openParPos<closeParPos){const transformType=transformText.substr(0,openParPos),array=parseFloats(transformText.substr(openParPos+1,closeParPos-openParPos-1));switch(currentTransform.identity(),transformType){case"translate":if(array.length>=1){const tx=array[0];let ty=tx;array.length>=2&&(ty=array[1]),currentTransform.translate(tx,ty)}break;case"rotate":if(array.length>=1){let angle=0,cx=0,cy=0;angle=-array[0]*Math.PI/180,array.length>=3&&(cx=array[1],cy=array[2]),tempTransform1.identity().translate(-cx,-cy),tempTransform2.identity().rotate(angle),tempTransform3.multiplyMatrices(tempTransform2,tempTransform1),tempTransform1.identity().translate(cx,cy),currentTransform.multiplyMatrices(tempTransform1,tempTransform3)}break;case"scale":if(array.length>=1){const scaleX=array[0];let scaleY=scaleX;array.length>=2&&(scaleY=array[1]),currentTransform.scale(scaleX,scaleY)}break;case"skewX":1===array.length&&currentTransform.set(1,Math.tan(array[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":1===array.length&&currentTransform.set(1,0,0,Math.tan(array[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":6===array.length&&currentTransform.set(array[0],array[2],array[4],array[1],array[3],array[5],0,0,1)}}transform.premultiply(currentTransform)}}return transform}(node);transformStack.length>0&&transform.premultiply(transformStack[transformStack.length-1]);return currentTransform.copy(transform),transformStack.push(transform),transform}(node);let traverseChildNodes=!0,path=null;switch(node.nodeName){case"svg":break;case"style":!function parseCSSStylesheet(node){if(!node.sheet||!node.sheet.cssRules||!node.sheet.cssRules.length)return;for(let i=0;i<node.sheet.cssRules.length;i++){const stylesheet=node.sheet.cssRules[i];if(1!==stylesheet.type)continue;const selectorList=stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i=>i.trim()));for(let j=0;j<selectorList.length;j++)stylesheets[selectorList[j]]=Object.assign(stylesheets[selectorList[j]]||{},stylesheet.style)}}(node);break;case"g":style=parseStyle(node,style);break;case"path":style=parseStyle(node,style),node.hasAttribute("d")&&(path=function parsePathNode(node){const path=new three_module.T_1,point=new three_module.FM8,control=new three_module.FM8,firstPoint=new three_module.FM8;let isFirstPoint=!0,doSetFirstPoint=!1;const d=node.getAttribute("d"),commands=d.match(/[a-df-z][^a-df-z]*/gi);for(let i=0,l=commands.length;i<l;i++){const command=commands[i],type=command.charAt(0),data=command.substr(1).trim();let numbers;switch(!0===isFirstPoint&&(doSetFirstPoint=!0,isFirstPoint=!1),type){case"M":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2)point.x=numbers[j+0],point.y=numbers[j+1],control.x=point.x,control.y=point.y,0===j?path.moveTo(point.x,point.y):path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"H":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j++)point.x=numbers[j],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"V":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j++)point.y=numbers[j],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"L":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2)point.x=numbers[j+0],point.y=numbers[j+1],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"C":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=6)path.bezierCurveTo(numbers[j+0],numbers[j+1],numbers[j+2],numbers[j+3],numbers[j+4],numbers[j+5]),control.x=numbers[j+2],control.y=numbers[j+3],point.x=numbers[j+4],point.y=numbers[j+5],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"S":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=4)path.bezierCurveTo(getReflection(point.x,control.x),getReflection(point.y,control.y),numbers[j+0],numbers[j+1],numbers[j+2],numbers[j+3]),control.x=numbers[j+0],control.y=numbers[j+1],point.x=numbers[j+2],point.y=numbers[j+3],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"Q":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=4)path.quadraticCurveTo(numbers[j+0],numbers[j+1],numbers[j+2],numbers[j+3]),control.x=numbers[j+0],control.y=numbers[j+1],point.x=numbers[j+2],point.y=numbers[j+3],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"T":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2){const rx=getReflection(point.x,control.x),ry=getReflection(point.y,control.y);path.quadraticCurveTo(rx,ry,numbers[j+0],numbers[j+1]),control.x=rx,control.y=ry,point.x=numbers[j+0],point.y=numbers[j+1],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case"A":numbers=parseFloats(data,[3,4],7);for(let j=0,jl=numbers.length;j<jl;j+=7){if(numbers[j+5]==point.x&&numbers[j+6]==point.y)continue;const start=point.clone();point.x=numbers[j+5],point.y=numbers[j+6],control.x=point.x,control.y=point.y,parseArcCommand(path,numbers[j],numbers[j+1],numbers[j+2],numbers[j+3],numbers[j+4],start,point),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case"m":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2)point.x+=numbers[j+0],point.y+=numbers[j+1],control.x=point.x,control.y=point.y,0===j?path.moveTo(point.x,point.y):path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"h":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j++)point.x+=numbers[j],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"v":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j++)point.y+=numbers[j],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"l":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2)point.x+=numbers[j+0],point.y+=numbers[j+1],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"c":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=6)path.bezierCurveTo(point.x+numbers[j+0],point.y+numbers[j+1],point.x+numbers[j+2],point.y+numbers[j+3],point.x+numbers[j+4],point.y+numbers[j+5]),control.x=point.x+numbers[j+2],control.y=point.y+numbers[j+3],point.x+=numbers[j+4],point.y+=numbers[j+5],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"s":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=4)path.bezierCurveTo(getReflection(point.x,control.x),getReflection(point.y,control.y),point.x+numbers[j+0],point.y+numbers[j+1],point.x+numbers[j+2],point.y+numbers[j+3]),control.x=point.x+numbers[j+0],control.y=point.y+numbers[j+1],point.x+=numbers[j+2],point.y+=numbers[j+3],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"q":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=4)path.quadraticCurveTo(point.x+numbers[j+0],point.y+numbers[j+1],point.x+numbers[j+2],point.y+numbers[j+3]),control.x=point.x+numbers[j+0],control.y=point.y+numbers[j+1],point.x+=numbers[j+2],point.y+=numbers[j+3],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"t":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2){const rx=getReflection(point.x,control.x),ry=getReflection(point.y,control.y);path.quadraticCurveTo(rx,ry,point.x+numbers[j+0],point.y+numbers[j+1]),control.x=rx,control.y=ry,point.x=point.x+numbers[j+0],point.y=point.y+numbers[j+1],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case"a":numbers=parseFloats(data,[3,4],7);for(let j=0,jl=numbers.length;j<jl;j+=7){if(0==numbers[j+5]&&0==numbers[j+6])continue;const start=point.clone();point.x+=numbers[j+5],point.y+=numbers[j+6],control.x=point.x,control.y=point.y,parseArcCommand(path,numbers[j],numbers[j+1],numbers[j+2],numbers[j+3],numbers[j+4],start,point),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case"Z":case"z":path.currentPath.autoClose=!0,path.currentPath.curves.length>0&&(point.copy(firstPoint),path.currentPath.currentPoint.copy(point),isFirstPoint=!0);break;default:console.warn(command)}doSetFirstPoint=!1}return path}(node));break;case"rect":style=parseStyle(node,style),path=function parseRectNode(node){const x=parseFloatWithUnits(node.getAttribute("x")||0),y=parseFloatWithUnits(node.getAttribute("y")||0),rx=parseFloatWithUnits(node.getAttribute("rx")||0),ry=parseFloatWithUnits(node.getAttribute("ry")||0),w=parseFloatWithUnits(node.getAttribute("width")),h=parseFloatWithUnits(node.getAttribute("height")),path=new three_module.T_1;path.moveTo(x+2*rx,y),path.lineTo(x+w-2*rx,y),(0!==rx||0!==ry)&&path.bezierCurveTo(x+w,y,x+w,y,x+w,y+2*ry);path.lineTo(x+w,y+h-2*ry),(0!==rx||0!==ry)&&path.bezierCurveTo(x+w,y+h,x+w,y+h,x+w-2*rx,y+h);path.lineTo(x+2*rx,y+h),(0!==rx||0!==ry)&&path.bezierCurveTo(x,y+h,x,y+h,x,y+h-2*ry);path.lineTo(x,y+2*ry),(0!==rx||0!==ry)&&path.bezierCurveTo(x,y,x,y,x+2*rx,y);return path}(node);break;case"polygon":style=parseStyle(node,style),path=function parsePolygonNode(node){function iterator(match,a,b){const x=parseFloatWithUnits(a),y=parseFloatWithUnits(b);0===index?path.moveTo(x,y):path.lineTo(x,y),index++}const regex=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,path=new three_module.T_1;let index=0;return node.getAttribute("points").replace(regex,iterator),path.currentPath.autoClose=!0,path}(node);break;case"polyline":style=parseStyle(node,style),path=function parsePolylineNode(node){function iterator(match,a,b){const x=parseFloatWithUnits(a),y=parseFloatWithUnits(b);0===index?path.moveTo(x,y):path.lineTo(x,y),index++}const regex=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,path=new three_module.T_1;let index=0;return node.getAttribute("points").replace(regex,iterator),path.currentPath.autoClose=!1,path}(node);break;case"circle":style=parseStyle(node,style),path=function parseCircleNode(node){const x=parseFloatWithUnits(node.getAttribute("cx")||0),y=parseFloatWithUnits(node.getAttribute("cy")||0),r=parseFloatWithUnits(node.getAttribute("r")||0),subpath=new three_module.y$t;subpath.absarc(x,y,r,0,2*Math.PI,!0);const path=new three_module.T_1;return path.subPaths.push(subpath),path}(node);break;case"ellipse":style=parseStyle(node,style),path=function parseEllipseNode(node){const x=parseFloatWithUnits(node.getAttribute("cx")||0),y=parseFloatWithUnits(node.getAttribute("cy")||0),rx=parseFloatWithUnits(node.getAttribute("rx")||0),ry=parseFloatWithUnits(node.getAttribute("ry")||0),subpath=new three_module.y$t;subpath.absellipse(x,y,rx,ry,0,2*Math.PI,!0,0);const path=new three_module.T_1;return path.subPaths.push(subpath),path}(node);break;case"line":style=parseStyle(node,style),path=function parseLineNode(node){const x1=parseFloatWithUnits(node.getAttribute("x1")||0),y1=parseFloatWithUnits(node.getAttribute("y1")||0),x2=parseFloatWithUnits(node.getAttribute("x2")||0),y2=parseFloatWithUnits(node.getAttribute("y2")||0),path=new three_module.T_1;return path.moveTo(x1,y1),path.lineTo(x2,y2),path.currentPath.autoClose=!1,path}(node);break;case"defs":traverseChildNodes=!1,function parseDefs(node){scope.defs||(scope.defs=[]);const nodes=node.childNodes;for(const node of nodes){const stops=node.childNodes;for(const stop of stops)if(stop.hasAttribute&&stop.hasAttribute("stop-color")){scope.defs[node.id]=stop.getAttribute("stop-color");break}}}(node);break;case"use":style=parseStyle(node,style);const usedNodeId=node.href.baseVal.substring(1),usedNode=node.viewportElement.getElementById(usedNodeId);usedNode?parseNode(usedNode,style):console.warn("SVGLoader: 'use node' references non-existent node id: "+usedNodeId)}if(path&&(void 0!==style.fill&&"none"!==style.fill&&"currentColor"!=style.fill&&path.color.setStyle(style.fill),function transformPath(path,m){function transfVec2(v2){tempV3.set(v2.x,v2.y,1).applyMatrix3(m),v2.set(tempV3.x,tempV3.y)}const isRotated=function isTransformRotated(m){return 0!==m.elements[1]||0!==m.elements[3]}(m),subPaths=path.subPaths;for(let i=0,n=subPaths.length;i<n;i++){const curves=subPaths[i].curves;for(let j=0;j<curves.length;j++){const curve=curves[j];curve.isLineCurve?(transfVec2(curve.v1),transfVec2(curve.v2)):curve.isCubicBezierCurve?(transfVec2(curve.v0),transfVec2(curve.v1),transfVec2(curve.v2),transfVec2(curve.v3)):curve.isQuadraticBezierCurve?(transfVec2(curve.v0),transfVec2(curve.v1),transfVec2(curve.v2)):curve.isEllipseCurve&&(isRotated&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),tempV2.set(curve.aX,curve.aY),transfVec2(tempV2),curve.aX=tempV2.x,curve.aY=tempV2.y,curve.xRadius*=getTransformScaleX(m),curve.yRadius*=getTransformScaleY(m))}}}(path,currentTransform),paths.push(path),path.userData={node,style}),traverseChildNodes){const nodes=node.childNodes;for(let i=0;i<nodes.length;i++)parseNode(nodes[i],style)}transform&&(transformStack.pop(),transformStack.length>0?currentTransform.copy(transformStack[transformStack.length-1]):currentTransform.identity())}(xml.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4});return{paths,xml:xml.documentElement}}static createShapes(shapePath){const IntersectionLocationType_ORIGIN=0,IntersectionLocationType_DESTINATION=1,IntersectionLocationType_BETWEEN=2,IntersectionLocationType_LEFT=3,IntersectionLocationType_RIGHT=4,IntersectionLocationType_BEHIND=5,IntersectionLocationType_BEYOND=6,classifyResult={loc:IntersectionLocationType_ORIGIN,t:0};function findEdgeIntersection(a0,a1,b0,b1){const x1=a0.x,x2=a1.x,x3=b0.x,x4=b1.x,y1=a0.y,y2=a1.y,y3=b0.y,y4=b1.y,nom1=(x4-x3)*(y1-y3)-(y4-y3)*(x1-x3),denom=(y4-y3)*(x2-x1)-(x4-x3)*(y2-y1),t1=nom1/denom,t2=((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3))/denom;if(0===denom&&0!==nom1||t1<=0||t1>=1||t2<0||t2>1)return null;if(0===nom1&&0===denom){for(let i=0;i<2;i++){if(classifyPoint(0===i?b0:b1,a0,a1),classifyResult.loc==IntersectionLocationType_ORIGIN){const point=0===i?b0:b1;return{x:point.x,y:point.y,t:classifyResult.t}}if(classifyResult.loc==IntersectionLocationType_BETWEEN){return{x:+(x1+classifyResult.t*(x2-x1)).toPrecision(10),y:+(y1+classifyResult.t*(y2-y1)).toPrecision(10),t:classifyResult.t}}}return null}for(let i=0;i<2;i++)if(classifyPoint(0===i?b0:b1,a0,a1),classifyResult.loc==IntersectionLocationType_ORIGIN){const point=0===i?b0:b1;return{x:point.x,y:point.y,t:classifyResult.t}}return{x:+(x1+t1*(x2-x1)).toPrecision(10),y:+(y1+t1*(y2-y1)).toPrecision(10),t:t1}}function classifyPoint(p,edgeStart,edgeEnd){const ax=edgeEnd.x-edgeStart.x,ay=edgeEnd.y-edgeStart.y,bx=p.x-edgeStart.x,by=p.y-edgeStart.y,sa=ax*by-bx*ay;if(p.x===edgeStart.x&&p.y===edgeStart.y)return classifyResult.loc=IntersectionLocationType_ORIGIN,void(classifyResult.t=0);if(p.x===edgeEnd.x&&p.y===edgeEnd.y)return classifyResult.loc=IntersectionLocationType_DESTINATION,void(classifyResult.t=1);if(sa<-Number.EPSILON)return void(classifyResult.loc=IntersectionLocationType_LEFT);if(sa>Number.EPSILON)return void(classifyResult.loc=IntersectionLocationType_RIGHT);if(ax*bx<0||ay*by<0)return void(classifyResult.loc=IntersectionLocationType_BEHIND);if(Math.sqrt(ax*ax+ay*ay)<Math.sqrt(bx*bx+by*by))return void(classifyResult.loc=IntersectionLocationType_BEYOND);let t;t=0!==ax?bx/ax:by/ay,classifyResult.loc=IntersectionLocationType_BETWEEN,classifyResult.t=t}function getScanlineIntersections(scanline,boundingBox,paths){const center=new three_module.FM8;boundingBox.getCenter(center);const allIntersections=[];return paths.forEach((path=>{if(path.boundingBox.containsPoint(center)){(function getIntersections(path1,path2){const intersectionsRaw=[],intersections=[];for(let index=1;index<path1.length;index++){const path1EdgeStart=path1[index-1],path1EdgeEnd=path1[index];for(let index2=1;index2<path2.length;index2++){const intersection=findEdgeIntersection(path1EdgeStart,path1EdgeEnd,path2[index2-1],path2[index2]);null!==intersection&&void 0===intersectionsRaw.find((i=>i.t<=intersection.t+Number.EPSILON&&i.t>=intersection.t-Number.EPSILON))&&(intersectionsRaw.push(intersection),intersections.push(new three_module.FM8(intersection.x,intersection.y)))}}return intersections})(scanline,path.points).forEach((p=>{allIntersections.push({identifier:path.identifier,isCW:path.isCW,point:p})}))}})),allIntersections.sort(((i1,i2)=>i1.point.x-i2.point.x)),allIntersections}let identifier=0,scanlineMinX=999999999,scanlineMaxX=-999999999,simplePaths=shapePath.subPaths.map((p=>{const points=p.getPoints();let maxY=-999999999,minY=999999999,maxX=-999999999,minX=999999999;for(let i=0;i<points.length;i++){const p=points[i];p.y>maxY&&(maxY=p.y),p.y<minY&&(minY=p.y),p.x>maxX&&(maxX=p.x),p.x<minX&&(minX=p.x)}return scanlineMaxX<=maxX&&(scanlineMaxX=maxX+1),scanlineMinX>=minX&&(scanlineMinX=minX-1),{points,isCW:three_module.iDF.isClockWise(points),identifier:identifier++,boundingBox:new three_module.TUj(new three_module.FM8(minX,minY),new three_module.FM8(maxX,maxY))}}));simplePaths=simplePaths.filter((sp=>sp.points.length>0));const isAHole=simplePaths.map((p=>function isHoleTo(simplePath,allPaths,scanlineMinX,scanlineMaxX,_fillRule){null!=_fillRule&&""!==_fillRule||(_fillRule="nonzero");const centerBoundingBox=new three_module.FM8;simplePath.boundingBox.getCenter(centerBoundingBox);const scanlineIntersections=getScanlineIntersections([new three_module.FM8(scanlineMinX,centerBoundingBox.y),new three_module.FM8(scanlineMaxX,centerBoundingBox.y)],simplePath.boundingBox,allPaths);scanlineIntersections.sort(((i1,i2)=>i1.point.x-i2.point.x));const baseIntersections=[],otherIntersections=[];scanlineIntersections.forEach((i=>{i.identifier===simplePath.identifier?baseIntersections.push(i):otherIntersections.push(i)}));const firstXOfPath=baseIntersections[0].point.x,stack=[];let i=0;for(;i<otherIntersections.length&&otherIntersections[i].point.x<firstXOfPath;)stack.length>0&&stack[stack.length-1]===otherIntersections[i].identifier?stack.pop():stack.push(otherIntersections[i].identifier),i++;if(stack.push(simplePath.identifier),"evenodd"===_fillRule){const isHole=stack.length%2==0,isHoleFor=stack[stack.length-2];return{identifier:simplePath.identifier,isHole,for:isHoleFor}}if("nonzero"===_fillRule){let isHole=!0,isHoleFor=null,lastCWValue=null;for(let i=0;i<stack.length;i++){const identifier=stack[i];isHole?(lastCWValue=allPaths[identifier].isCW,isHole=!1,isHoleFor=identifier):lastCWValue!==allPaths[identifier].isCW&&(lastCWValue=allPaths[identifier].isCW,isHole=!0)}return{identifier:simplePath.identifier,isHole,for:isHoleFor}}console.warn('fill-rule: "'+_fillRule+'" is currently not implemented.')}(p,simplePaths,scanlineMinX,scanlineMaxX,shapePath.userData.style.fillRule))),shapesToReturn=[];return simplePaths.forEach((p=>{if(!isAHole[p.identifier].isHole){const shape=new three_module.bnF(p.points);isAHole.filter((h=>h.isHole&&h.for===p.identifier)).forEach((h=>{const path=simplePaths[h.identifier];shape.holes.push(new three_module.y$t(path.points))})),shapesToReturn.push(shape)}})),shapesToReturn}static getStrokeStyle(width,color,lineJoin,lineCap,miterLimit){return{strokeColor:color=void 0!==color?color:"#000",strokeWidth:width=void 0!==width?width:1,strokeLineJoin:lineJoin=void 0!==lineJoin?lineJoin:"miter",strokeLineCap:lineCap=void 0!==lineCap?lineCap:"butt",strokeMiterLimit:miterLimit=void 0!==miterLimit?miterLimit:4}}static pointsToStroke(points,style,arcDivisions,minDistance){const vertices=[],normals=[],uvs=[];if(0===SVGLoader.pointsToStrokeWithBuffers(points,style,arcDivisions,minDistance,vertices,normals,uvs))return null;const geometry=new three_module.u9r;return geometry.setAttribute("position",new three_module.a$l(vertices,3)),geometry.setAttribute("normal",new three_module.a$l(normals,3)),geometry.setAttribute("uv",new three_module.a$l(uvs,2)),geometry}static pointsToStrokeWithBuffers(points,style,arcDivisions,minDistance,vertices,normals,uvs,vertexOffset){const tempV2_1=new three_module.FM8,tempV2_2=new three_module.FM8,tempV2_3=new three_module.FM8,tempV2_4=new three_module.FM8,tempV2_5=new three_module.FM8,tempV2_6=new three_module.FM8,tempV2_7=new three_module.FM8,lastPointL=new three_module.FM8,lastPointR=new three_module.FM8,point0L=new three_module.FM8,point0R=new three_module.FM8,currentPointL=new three_module.FM8,currentPointR=new three_module.FM8,nextPointL=new three_module.FM8,nextPointR=new three_module.FM8,innerPoint=new three_module.FM8,outerPoint=new three_module.FM8;arcDivisions=void 0!==arcDivisions?arcDivisions:12,minDistance=void 0!==minDistance?minDistance:.001,vertexOffset=void 0!==vertexOffset?vertexOffset:0;const numPoints=(points=function removeDuplicatedPoints(points){let dupPoints=!1;for(let i=1,n=points.length-1;i<n;i++)if(points[i].distanceTo(points[i+1])<minDistance){dupPoints=!0;break}if(!dupPoints)return points;const newPoints=[];newPoints.push(points[0]);for(let i=1,n=points.length-1;i<n;i++)points[i].distanceTo(points[i+1])>=minDistance&&newPoints.push(points[i]);return newPoints.push(points[points.length-1]),newPoints}(points)).length;if(numPoints<2)return 0;const isClosed=points[0].equals(points[numPoints-1]);let currentPoint,nextPoint,previousPoint=points[0];const strokeWidth2=style.strokeWidth/2,deltaU=1/(numPoints-1);let u1,innerSideModified,joinIsOnLeftSide,isMiter,u0=0,initialJoinIsOnLeftSide=!1,numVertices=0,currentCoordinate=3*vertexOffset,currentCoordinateUV=2*vertexOffset;getNormal(points[0],points[1],tempV2_1).multiplyScalar(strokeWidth2),lastPointL.copy(points[0]).sub(tempV2_1),lastPointR.copy(points[0]).add(tempV2_1),point0L.copy(lastPointL),point0R.copy(lastPointR);for(let iPoint=1;iPoint<numPoints;iPoint++){currentPoint=points[iPoint],nextPoint=iPoint===numPoints-1?isClosed?points[1]:void 0:points[iPoint+1];const normal1=tempV2_1;if(getNormal(previousPoint,currentPoint,normal1),tempV2_3.copy(normal1).multiplyScalar(strokeWidth2),currentPointL.copy(currentPoint).sub(tempV2_3),currentPointR.copy(currentPoint).add(tempV2_3),u1=u0+deltaU,innerSideModified=!1,void 0!==nextPoint){getNormal(currentPoint,nextPoint,tempV2_2),tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2),nextPointL.copy(currentPoint).sub(tempV2_3),nextPointR.copy(currentPoint).add(tempV2_3),joinIsOnLeftSide=!0,tempV2_3.subVectors(nextPoint,previousPoint),normal1.dot(tempV2_3)<0&&(joinIsOnLeftSide=!1),1===iPoint&&(initialJoinIsOnLeftSide=joinIsOnLeftSide),tempV2_3.subVectors(nextPoint,currentPoint),tempV2_3.normalize();const dot=Math.abs(normal1.dot(tempV2_3));if(0!==dot){const miterSide=strokeWidth2/dot;tempV2_3.multiplyScalar(-miterSide),tempV2_4.subVectors(currentPoint,previousPoint),tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3),innerPoint.copy(tempV2_5).negate();const miterLength2=tempV2_5.length(),segmentLengthPrev=tempV2_4.length();tempV2_4.divideScalar(segmentLengthPrev),tempV2_6.subVectors(nextPoint,currentPoint);const segmentLengthNext=tempV2_6.length();switch(tempV2_6.divideScalar(segmentLengthNext),tempV2_4.dot(innerPoint)<segmentLengthPrev&&tempV2_6.dot(innerPoint)<segmentLengthNext&&(innerSideModified=!0),outerPoint.copy(tempV2_5).add(currentPoint),innerPoint.add(currentPoint),isMiter=!1,innerSideModified?joinIsOnLeftSide?(nextPointR.copy(innerPoint),currentPointR.copy(innerPoint)):(nextPointL.copy(innerPoint),currentPointL.copy(innerPoint)):makeSegmentTriangles(),style.strokeLineJoin){case"bevel":makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u1);break;case"round":createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified),joinIsOnLeftSide?makeCircularSector(currentPoint,currentPointL,nextPointL,u1,0):makeCircularSector(currentPoint,nextPointR,currentPointR,u1,1);break;default:const miterFraction=strokeWidth2*style.strokeMiterLimit/miterLength2;if(miterFraction<1){if("miter-clip"!==style.strokeLineJoin){makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u1);break}createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified),joinIsOnLeftSide?(tempV2_6.subVectors(outerPoint,currentPointL).multiplyScalar(miterFraction).add(currentPointL),tempV2_7.subVectors(outerPoint,nextPointL).multiplyScalar(miterFraction).add(nextPointL),addVertex(currentPointL,u1,0),addVertex(tempV2_6,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(tempV2_6,u1,0),addVertex(tempV2_7,u1,0),addVertex(currentPoint,u1,.5),addVertex(tempV2_7,u1,0),addVertex(nextPointL,u1,0)):(tempV2_6.subVectors(outerPoint,currentPointR).multiplyScalar(miterFraction).add(currentPointR),tempV2_7.subVectors(outerPoint,nextPointR).multiplyScalar(miterFraction).add(nextPointR),addVertex(currentPointR,u1,1),addVertex(tempV2_6,u1,1),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(tempV2_6,u1,1),addVertex(tempV2_7,u1,1),addVertex(currentPoint,u1,.5),addVertex(tempV2_7,u1,1),addVertex(nextPointR,u1,1))}else innerSideModified?(joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(outerPoint,u1,0),addVertex(lastPointR,u0,1),addVertex(outerPoint,u1,0),addVertex(innerPoint,u1,1)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(outerPoint,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(outerPoint,u1,1)),joinIsOnLeftSide?nextPointL.copy(outerPoint):nextPointR.copy(outerPoint)):joinIsOnLeftSide?(addVertex(currentPointL,u1,0),addVertex(outerPoint,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(outerPoint,u1,0),addVertex(nextPointL,u1,0)):(addVertex(currentPointR,u1,1),addVertex(outerPoint,u1,1),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(outerPoint,u1,1),addVertex(nextPointR,u1,1)),isMiter=!0}}else makeSegmentTriangles()}else makeSegmentTriangles();isClosed||iPoint!==numPoints-1||addCapGeometry(points[0],point0L,point0R,joinIsOnLeftSide,!0,u0),u0=u1,previousPoint=currentPoint,lastPointL.copy(nextPointL),lastPointR.copy(nextPointR)}if(isClosed){if(innerSideModified&&vertices){let lastOuter=outerPoint,lastInner=innerPoint;initialJoinIsOnLeftSide!==joinIsOnLeftSide&&(lastOuter=innerPoint,lastInner=outerPoint),joinIsOnLeftSide?(isMiter||initialJoinIsOnLeftSide)&&(lastInner.toArray(vertices,0),lastInner.toArray(vertices,9),isMiter&&lastOuter.toArray(vertices,3)):!isMiter&&initialJoinIsOnLeftSide||(lastInner.toArray(vertices,3),lastInner.toArray(vertices,9),isMiter&&lastOuter.toArray(vertices,0))}}else addCapGeometry(currentPoint,currentPointL,currentPointR,joinIsOnLeftSide,!1,u1);return numVertices;function getNormal(p1,p2,result){return result.subVectors(p2,p1),result.set(-result.y,result.x).normalize()}function addVertex(position,u,v){vertices&&(vertices[currentCoordinate]=position.x,vertices[currentCoordinate+1]=position.y,vertices[currentCoordinate+2]=0,normals&&(normals[currentCoordinate]=0,normals[currentCoordinate+1]=0,normals[currentCoordinate+2]=1),currentCoordinate+=3,uvs&&(uvs[currentCoordinateUV]=u,uvs[currentCoordinateUV+1]=v,currentCoordinateUV+=2)),numVertices+=3}function makeCircularSector(center,p1,p2,u,v){tempV2_1.copy(p1).sub(center).normalize(),tempV2_2.copy(p2).sub(center).normalize();let angle=Math.PI;const dot=tempV2_1.dot(tempV2_2);Math.abs(dot)<1&&(angle=Math.abs(Math.acos(dot))),angle/=arcDivisions,tempV2_3.copy(p1);for(let i=0,il=arcDivisions-1;i<il;i++)tempV2_4.copy(tempV2_3).rotateAround(center,angle),addVertex(tempV2_3,u,v),addVertex(tempV2_4,u,v),addVertex(center,u,.5),tempV2_3.copy(tempV2_4);addVertex(tempV2_4,u,v),addVertex(p2,u,v),addVertex(center,u,.5)}function makeSegmentTriangles(){addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,1),addVertex(currentPointR,u1,0)}function makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u){innerSideModified?joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,0),addVertex(innerPoint,u1,1),addVertex(currentPointL,u,0),addVertex(nextPointL,u,0),addVertex(innerPoint,u,.5)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointR,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(currentPointR,u1,1),addVertex(currentPointR,u,1),addVertex(nextPointR,u,0),addVertex(innerPoint,u,.5)):joinIsOnLeftSide?(addVertex(currentPointL,u,0),addVertex(nextPointL,u,0),addVertex(currentPoint,u,.5)):(addVertex(currentPointR,u,1),addVertex(nextPointR,u,0),addVertex(currentPoint,u,.5))}function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified){innerSideModified&&(joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,0),addVertex(innerPoint,u1,1),addVertex(currentPointL,u0,0),addVertex(currentPoint,u1,.5),addVertex(innerPoint,u1,1),addVertex(currentPoint,u1,.5),addVertex(nextPointL,u0,0),addVertex(innerPoint,u1,1)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointR,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(currentPointR,u1,1),addVertex(currentPointR,u0,1),addVertex(innerPoint,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(innerPoint,u1,0),addVertex(nextPointR,u0,1)))}function addCapGeometry(center,p1,p2,joinIsOnLeftSide,start,u){switch(style.strokeLineCap){case"round":start?makeCircularSector(center,p2,p1,u,.5):makeCircularSector(center,p1,p2,u,.5);break;case"square":if(start)tempV2_1.subVectors(p1,center),tempV2_2.set(tempV2_1.y,-tempV2_1.x),tempV2_3.addVectors(tempV2_1,tempV2_2).add(center),tempV2_4.subVectors(tempV2_2,tempV2_1).add(center),joinIsOnLeftSide?(tempV2_3.toArray(vertices,3),tempV2_4.toArray(vertices,0),tempV2_4.toArray(vertices,9)):(tempV2_3.toArray(vertices,3),tempV2_3.toArray(vertices,9),tempV2_4.toArray(vertices,0));else{tempV2_1.subVectors(p2,center),tempV2_2.set(tempV2_1.y,-tempV2_1.x),tempV2_3.addVectors(tempV2_1,tempV2_2).add(center),tempV2_4.subVectors(tempV2_2,tempV2_1).add(center);const vl=vertices.length;joinIsOnLeftSide?(tempV2_3.toArray(vertices,vl-3),tempV2_4.toArray(vertices,vl-6),tempV2_4.toArray(vertices,vl-12)):(tempV2_3.toArray(vertices,vl-6),tempV2_4.toArray(vertices,vl-3),tempV2_4.toArray(vertices,vl-12))}}}}}let SvgLoaderService=class SvgLoaderService extends AbstractCacheService{getValue(key){return new Promise(((resolve,reject)=>{(new SVGLoader).load(key,(data=>{resolve(data.paths)}),void 0,reject)}))}};SvgLoaderService=(0,tslib_es6.gn)([(0,core.Injectable)()],SvgLoaderService);var abstract_asset_service=__webpack_require__("./projects/atft/src/lib/object/loader/services/abstract-asset.service.ts");let IconService=class IconService extends abstract_asset_service.b{constructor(){super(...arguments),this.defaultProvider="md"}init(){this.registerProvider("md",{url:"https://raw.githubusercontent.com/material-icons/material-icons/master/svg/?/baseline.svg",allowColorOverride:!0,isCCW:!1,noHoles:!1}),this.registerProvider("a",{url:"assets/svg/?.svg",allowColorOverride:!0,isCCW:!1,noHoles:!1}),this.registerProvider("az",{url:"https://raw.githubusercontent.com/makimenko/files/master/azure-icons/?.svg",allowColorOverride:!1,isCCW:!1,noHoles:!1}),this.registerProvider("g",{url:"https://raw.githubusercontent.com/makimenko/files/master/google-cloud-icons/?.svg",allowColorOverride:!0,isCCW:!1,noHoles:!1}),this.registerProvider("aws",{url:"https://raw.githubusercontent.com/makimenko/files/master/aws-icons/?.svg",allowColorOverride:!1,isCCW:!1,noHoles:!0})}defaultIfNotFound(icon){return{url:icon,allowColorOverride:!0,isCCW:!1,noHoles:!1}}getFinalResult(finalUrl,provider){return{url:finalUrl,allowColorOverride:provider.allowColorOverride,isCCW:provider.isCCW,noHoles:provider.noHoles}}};IconService=(0,tslib_es6.gn)([(0,core.Injectable)()],IconService);let SVGLoaderComponent=class SVGLoaderComponent extends AbstractModelLoader{get overrideMaterialColor(){return this._overrideMaterialColor}set overrideMaterialColor(value){this._overrideMaterialColor=value,this.object&&this.startLoading()}set icon(icon){const iconProvider=this.iconService.getSource(icon);this.model=iconProvider.url,this.isCCW=iconProvider.isCCW,this.noHoles=iconProvider.noHoles,iconProvider.allowColorOverride||(this.overrideMaterialColor=void 0)}get icon(){return this.model}constructor(rendererService,parent,svgLoader,iconService){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.svgLoader=svgLoader,this.iconService=iconService,this._overrideMaterialColor=void 0,this.material="basic",this.depthWrite=!0,this.centered=!0,this.isCCW=!1,this.noHoles=!1}loadLazyObject(){var _this=this;return(0,asyncToGenerator.Z)((function*(){const paths=yield _this.svgLoader.load(_this.model),group=new three_module.ZAu;for(const path of paths){const color=_this._overrideMaterialColor?_this._overrideMaterialColor:path.color,material=(0,applied_material.m)(color,_this.material,_this.depthWrite),shapes=path.toShapes(_this.isCCW);for(const shape of shapes){const geometry=new three_module.oa8(shape),mesh=new three_module.Kj0(geometry,material);group.add(mesh)}}return(_this.maxX||_this.maxY)&&scaleToFit(group,new three_module.Pa4(_this.maxX,_this.maxY,0)),_this.centered&&fixCenter(group),group}))()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]},{type:SvgLoaderService},{type:IconService}];static#_2=this.propDecorators={overrideMaterialColor:[{type:core.Input}],icon:[{type:core.Input}],material:[{type:core.Input}],depthWrite:[{type:core.Input}],maxX:[{type:core.Input}],maxY:[{type:core.Input}],centered:[{type:core.Input}],isCCW:[{type:core.Input}],noHoles:[{type:core.Input}]}};SVGLoaderComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-svg-loader",providers:[(0,provide_parent.T)(SVGLoaderComponent)],template:"<ng-content></ng-content>"})],SVGLoaderComponent);var STLLoader=__webpack_require__("./node_modules/three/examples/jsm/loaders/STLLoader.js");let StlLoaderComponent=class StlLoaderComponent extends AbstractModelLoader{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.loader=new STLLoader.j,this.materialColor="#FFFFFF",this.depthWrite=!0}loadLazyObject(){var _this=this;return(0,asyncToGenerator.Z)((function*(){return new Promise(((resolve,reject)=>{_this.loader.load(_this.model,(geometry=>{const material=(0,applied_material.m)(_this.materialColor,_this.material,_this.depthWrite),mesh=new three_module.Kj0(geometry,material);resolve(mesh)}),void 0,reject)}))}))()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={material:[{type:core.Input}],materialColor:[{type:core.Input}],depthWrite:[{type:core.Input}]}};StlLoaderComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-stl-loader",providers:[(0,provide_parent.T)(StlLoaderComponent)],template:"<ng-content></ng-content>"})],StlLoaderComponent);let AudioLoaderComponent=class AudioLoaderComponent extends AbstractModelLoader{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.loader=new three_module.mTL,this.listener=new three_module.SJI,this.sound=new three_module.BbS(this.listener),this.volume=.5,this.loop=!1,this.autoplay=!0,this.ready=new core.EventEmitter,this.audioLoaded=this.audioLoaded.bind(this)}initListener(){console.log("AudioLoaderComponent.initListener"),this.rendererService.getCamera().camera.add(this.listener)}loadLazyObject(){var _this=this;return(0,asyncToGenerator.Z)((function*(){return _this.initListener(),console.log("AudioLoaderComponent.loadLazyObject url",_this.url),new Promise(((resolve,reject)=>{_this.sound=new three_module.BbS(_this.listener),_this.loader.load(_this.url,_this.audioLoaded,void 0,reject),resolve(_this.sound)}))}))()}audioLoaded(buffer){console.log("AudioLoaderComponent.audioLoaded"),this.sound.setBuffer(buffer),this.sound.setLoop(this.loop),this.sound.setVolume(this.volume),this.sound.autoplay=this.autoplay,this.autoplay&&this.play(),this.ready.emit()}ngOnDestroy(){console.log("AudioLoaderComponent.ngOnDestroy"),super.ngOnDestroy(),this.sound.stop()}play(){this.sound.play()}pause(){this.sound.pause()}stop(){this.sound.stop()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={url:[{type:core.Input}],volume:[{type:core.Input}],loop:[{type:core.Input}],autoplay:[{type:core.Input}],ready:[{type:core.Output}]}};AudioLoaderComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-audio-loader",providers:[(0,provide_parent.T)(AudioLoaderComponent)],template:"<ng-content></ng-content>"})],AudioLoaderComponent);let AtftLoaderModule=class AtftLoaderModule{};AtftLoaderModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[ObjLoaderComponent,ObjectLoaderComponent,SVGLoaderComponent,StlLoaderComponent,AudioLoaderComponent],imports:[common.CommonModule],exports:[ObjLoaderComponent,ObjectLoaderComponent,SVGLoaderComponent,StlLoaderComponent,AudioLoaderComponent]})],AtftLoaderModule);var box_mesh_component=__webpack_require__("./projects/atft/src/lib/object/mesh/box-mesh.component.ts"),abstract_mesh_3d=__webpack_require__("./projects/atft/src/lib/object/mesh/abstract-mesh-3d.ts");let CylinderMeshComponent=class CylinderMeshComponent extends abstract_mesh_3d.x{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.radiusTop=1,this.radiusBottom=1,this.height=1,this.radialSegments=8,this.heightSegments=1,this.openEnded=!1,this.thetaStart=0,this.thetaLength=2*Math.PI}newObject3DInstance(){const geometry=new three_module.fHI(this.radiusTop,this.radiusBottom,this.height,this.radialSegments,this.heightSegments,this.openEnded,this.thetaStart,this.thetaLength),material=this.getMaterial(),mesh=new three_module.Kj0(geometry,material);return this.applyShadowProps(mesh),mesh}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={radiusTop:[{type:core.Input}],radiusBottom:[{type:core.Input}],height:[{type:core.Input}],radialSegments:[{type:core.Input}],heightSegments:[{type:core.Input}],openEnded:[{type:core.Input}],thetaStart:[{type:core.Input}],thetaLength:[{type:core.Input}]}};CylinderMeshComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-cylinder-mesh",providers:[(0,provide_parent.T)(CylinderMeshComponent)],template:"<ng-content></ng-content>"})],CylinderMeshComponent);let FrameMeshComponent=class FrameMeshComponent extends abstract_mesh_3d.x{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.thickness=2,this.sizeX=20,this.sizeY=20}getGeometry(){const halfX=(this.sizeX??1)/2,halfY=(this.sizeY??1)/2,t=this.thickness??1,shape=new three_module.bnF;shape.moveTo(-halfX,halfY),shape.lineTo(-halfX-t,halfY+t),shape.lineTo(halfX+t,halfY+t),shape.lineTo(halfX+t,-halfY-t),shape.lineTo(-halfX-t,-halfY-t),shape.lineTo(-halfX-t,halfY+t),shape.lineTo(-halfX,halfY),shape.lineTo(-halfX,-halfY),shape.lineTo(halfX,-halfY),shape.lineTo(halfX,halfY),shape.lineTo(-halfX,halfY);return new three_module.oa8(shape)}newObject3DInstance(){const material=this.getMaterial(),mesh=new three_module.Kj0(this.getGeometry(),material);return this.applyShadowProps(mesh),mesh}ngOnChanges(changes){if(!this.object)return;super.ngOnChanges(changes);let modified=!1;if(["sizeX","sizeY","thickness"].some((propName=>propName in changes))&&this.getObject()instanceof three_module.Kj0){const mesh=this.getObject();if(mesh.geometry instanceof three_module.oa8){const currentGeometry=mesh.geometry,newGeometry=this.getGeometry();currentGeometry.attributes=newGeometry.attributes}modified=!0}modified&&(this.changed.emit(),this.rendererService.render())}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={thickness:[{type:core.Input}],sizeX:[{type:core.Input}],sizeY:[{type:core.Input}]}};FrameMeshComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-frame-mesh",providers:[(0,provide_parent.T)(FrameMeshComponent)],template:"<ng-content></ng-content>"})],FrameMeshComponent);let PlaneMeshComponent=class PlaneMeshComponent extends abstract_mesh_3d.x{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.width=1,this.height=1,this.widthSegments=1,this.heightSegments=1}newObject3DInstance(){const geometry=new three_module._12(this.width,this.height,this.widthSegments,this.heightSegments),material=this.getMaterial(),mesh=new three_module.Kj0(geometry,material);return this.applyShadowProps(mesh),mesh}ngOnChanges(changes){if(!this.object)return;super.ngOnChanges(changes);let modified=!1;if(["width","height","widthSegments","heightSegments"].some((propName=>propName in changes))){if(this.getObject()instanceof three_module.Kj0){const mesh=this.getObject();if(mesh.geometry instanceof three_module._12){const currentGeometry=mesh.geometry,newGeometry=new three_module._12(this.width,this.height,this.widthSegments,this.heightSegments);currentGeometry.attributes=newGeometry.attributes}}modified=!0}modified&&(this.changed.emit(),this.rendererService.render())}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={width:[{type:core.Input}],height:[{type:core.Input}],widthSegments:[{type:core.Input}],heightSegments:[{type:core.Input}]}};PlaneMeshComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-plane-mesh",providers:[(0,provide_parent.T)(PlaneMeshComponent)],template:"<ng-content></ng-content>"})],PlaneMeshComponent);let SphereMeshComponent=class SphereMeshComponent extends abstract_mesh_3d.x{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent}newObject3DInstance(){const geometry=new three_module.xo$(this.radius,this.widthSegments,this.hightSegments),material=this.getMaterial(),mesh=new three_module.Kj0(geometry,material);return this.applyShadowProps(mesh),mesh}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={radius:[{type:core.Input}],widthSegments:[{type:core.Input}],hightSegments:[{type:core.Input}]}};SphereMeshComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-sphere-mesh",providers:[(0,provide_parent.T)(SphereMeshComponent)],template:"<ng-content></ng-content>"})],SphereMeshComponent);let TorusMeshComponent=class TorusMeshComponent extends abstract_mesh_3d.x{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.radius=.4,this.radialSegments=8,this.tubularSegments=6,this.arc=2*Math.PI}newObject3DInstance(){this.radius*=1,this.tube*=1,this.radialSegments*=1,this.tubularSegments*=1;const geometry=new three_module.XvJ(this.radius,this.tube,this.radialSegments,this.tubularSegments),material=this.getMaterial(),mesh=new three_module.Kj0(geometry,material);return this.applyShadowProps(mesh),mesh}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={radius:[{type:core.Input}],tube:[{type:core.Input}],radialSegments:[{type:core.Input}],tubularSegments:[{type:core.Input}],arc:[{type:core.Input}]}};TorusMeshComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-torus-mesh",providers:[(0,provide_parent.T)(TorusMeshComponent)],template:"<ng-content></ng-content>"})],TorusMeshComponent);let GridMeshComponent=class GridMeshComponent extends abstract_mesh_3d.x{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.size=5,this.iterationsX=30,this.iterationsY=30,this.offset=1.05}newObject3DInstance(){const geometry=new three_module.u9r,vertices=[],d=this.size,x0=-this.iterationsX*(d*this.offset)/2,y0=-this.iterationsY*(d*this.offset)/2;let x=x0,y=y0;for(let i=0;i<this.iterationsX;i++){for(let j=0;j<this.iterationsY;j++)vertices.push(x,y,0),vertices.push(x+d,y+d,0),vertices.push(x,y+d,0),vertices.push(x+d,y+d,0),vertices.push(x,y,0),vertices.push(x+d,y,0),y+=this.size*this.offset;y=y0,x+=this.size*this.offset}geometry.setAttribute("position",new three_module.TlE(new Float32Array(vertices),3));const material=this.getMaterial(),mesh=new three_module.Kj0(geometry,material);return geometry.computeBoundingBox(),geometry.computeVertexNormals(),this.applyShadowProps(mesh),mesh}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={size:[{type:core.Input}],iterationsX:[{type:core.Input}],iterationsY:[{type:core.Input}],offset:[{type:core.Input}]}};GridMeshComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-grid-mesh",providers:[(0,provide_parent.T)(GridMeshComponent)],template:"<ng-content></ng-content>"})],GridMeshComponent);var animation_service=__webpack_require__("./projects/atft/src/lib/animation/animation.service.ts");let VideoMeshComponent=class VideoMeshComponent extends abstract_mesh_3d.x{constructor(rendererService,parent,animationService){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.animationService=animationService,this.width=1,this.height=1,this.type="video/mp4",this.autoplay=!0,this.loop=!0,this.muted=!0,this.video=document.createElement("video"),this.widthSegments=1,this.heightSegments=1,this.videoPlaybackStarted=!1,this.playbackError=!1}newObject3DInstance(){const geometry=new three_module._12(this.width,this.height,this.widthSegments,this.heightSegments),material=this.getMaterial(),mesh=new three_module.Kj0(geometry,material);return this.applyShadowProps(mesh),mesh}getMaterial(){const source=document.createElement("source");source.src=this.videoSrc,source.type=this.type,this.video.appendChild(source),this.video.crossOrigin="anonymous",this.video.autoplay=!1,this.video.loop=this.loop,this.video.muted=this.muted;const texture=new three_module.fO1(this.video);return new three_module.vBJ({color:16777215,map:texture})}animate(){}ngAfterViewInit(){super.ngAfterViewInit(),this.autoplay&&(this.animationService.start(),this.animate=this.animate.bind(this),this.animation=this.animationService.animate.subscribe(this.animate),this.video.load(),this.video.addEventListener("canplay",(()=>{this.video&&this.video.play().then((()=>{this.videoPlaybackStarted=!0}),(()=>{this.playbackError=!0}))})))}ngOnDestroy(){this.video&&(this.animation?.unsubscribe(),this.video.pause(),this.video.remove())}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]},{type:animation_service.Y}];static#_2=this.propDecorators={width:[{type:core.Input}],height:[{type:core.Input}],videoSrc:[{type:core.Input}],type:[{type:core.Input}],autoplay:[{type:core.Input}],loop:[{type:core.Input}],muted:[{type:core.Input}]}};VideoMeshComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-video-mesh",providers:[(0,provide_parent.T)(VideoMeshComponent)],template:"<ng-content></ng-content>"})],VideoMeshComponent);let AtftMeshModule=class AtftMeshModule{};AtftMeshModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[box_mesh_component.T,CylinderMeshComponent,FrameMeshComponent,PlaneMeshComponent,SphereMeshComponent,TorusMeshComponent,GridMeshComponent,VideoMeshComponent],imports:[common.CommonModule],exports:[box_mesh_component.T,CylinderMeshComponent,FrameMeshComponent,PlaneMeshComponent,SphereMeshComponent,TorusMeshComponent,GridMeshComponent,VideoMeshComponent]})],AtftMeshModule);var FontLoader=__webpack_require__("./node_modules/three/examples/jsm/loaders/FontLoader.js");let FontService=class FontService extends AbstractCacheService{getValue(key){return new Promise((resolve=>{(new FontLoader.J).load(key,resolve)}))}};FontService=(0,tslib_es6.gn)([(0,core.Injectable)()],FontService);var TextGeometry=__webpack_require__("./node_modules/three/examples/jsm/geometries/TextGeometry.js");let TextMeshComponent=class TextMeshComponent extends AbstractLazyObject3D{set materialColor(materialColor){this._materialColor=materialColor,this.object&&this.startLoading()}get materialColor(){return this._materialColor}set text(text){this._text=text,this.object&&this.startLoading()}get text(){return this._text}constructor(rendererService,parent,font){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.font=font,this.material="basic",this._materialColor="#DADADA",this._text="Text",this.size=10,this.height=.3,this.curveSegments=2,this.bevelEnabled=!1,this.bevelThickness=.1,this.bevelSize=.1,this.bevelOffset=0,this.bevelSegments=1,this.fontUrl="./assets/font/helvetiker_regular.typeface.json",this.castShadow=!0,this.receiveShadow=!0,this.depthWrite=!0,this.centered=!0}getMaterial(){return(0,applied_material.m)(this.materialColor,this.material,this.depthWrite)}loadLazyObject(){var _this=this;return(0,asyncToGenerator.Z)((function*(){const font=yield _this.font.load(_this.fontUrl);return _this.getTextMesh(font)}))()}getTextMesh(font){if(this.text){const geometry=new TextGeometry.M(this.text,{font,size:this.size,height:this.height,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize,bevelOffset:this.bevelOffset,bevelSegments:this.bevelOffset}),material=this.getMaterial(),mesh=new three_module.Kj0(geometry,material);return mesh.castShadow=this.castShadow,mesh.receiveShadow=this.receiveShadow,this.centered&&fixCenter(mesh),mesh}return new three_module.Kj0}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]},{type:FontService}];static#_2=this.propDecorators={material:[{type:core.Input}],materialColor:[{type:core.Input}],text:[{type:core.Input}],size:[{type:core.Input}],height:[{type:core.Input}],curveSegments:[{type:core.Input}],bevelEnabled:[{type:core.Input}],bevelThickness:[{type:core.Input}],bevelSize:[{type:core.Input}],bevelOffset:[{type:core.Input}],bevelSegments:[{type:core.Input}],fontUrl:[{type:core.Input}],castShadow:[{type:core.Input}],receiveShadow:[{type:core.Input}],depthWrite:[{type:core.Input}],centered:[{type:core.Input}]}};TextMeshComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-text-mesh",providers:[(0,provide_parent.T)(TextMeshComponent)],template:"<ng-content></ng-content>"})],TextMeshComponent);let AtftTextModule=class AtftTextModule{};AtftTextModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[TextMeshComponent],imports:[common.CommonModule],exports:[TextMeshComponent]})],AtftTextModule);let SceneComponent=class SceneComponent extends abstract_object_3d.l{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.background="#ffffff",rendererService.setScene(this)}newObject3DInstance(){const scene=new three_module.xsS;return scene.background=new three_module.Ilk(this.background),scene}updateParent(){}ngOnChanges(changes){if(super.ngOnChanges(changes),!this.object)return;let modified=!1;["background"].some((propName=>propName in changes))&&(this.getObject().background=new three_module.Ilk(this.background),modified=!0),modified&&this.rendererService.render()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={background:[{type:core.Input}]}};SceneComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-scene",providers:[(0,provide_parent.T)(SceneComponent)],template:"<ng-content></ng-content>"})],SceneComponent);var content_projection_component=__webpack_require__("./projects/atft/src/lib/object/content-projection.component.ts"),model_service=__webpack_require__("./projects/atft/src/lib/object/loader/services/model.service.ts");let AtftObjectModule=class AtftObjectModule{};AtftObjectModule=(0,tslib_es6.gn)([(0,core.NgModule)({imports:[common.CommonModule,AtftConnectorModule,AtftHelperModule,AtftLightModule,AtftLoaderModule,AtftMeshModule,AtftTextModule],declarations:[SceneComponent,content_projection_component.H],exports:[SceneComponent,AtftConnectorModule,AtftHelperModule,AtftLightModule,AtftLoaderModule,AtftMeshModule,AtftTextModule],providers:[FontService,SvgLoaderService,IconService,ObjLoaderService,model_service.b]})],AtftObjectModule);var RaycasterEvent,controls_componentngResource=__webpack_require__("./projects/atft/src/lib/control/controls.component.scss?ngResource"),controls_componentngResource_default=__webpack_require__.n(controls_componentngResource),OrbitControls=__webpack_require__("./node_modules/three/examples/jsm/controls/OrbitControls.js");!function(RaycasterEvent){RaycasterEvent.mouseEnter="mouseEnter",RaycasterEvent.mouseExit="mouseExit",RaycasterEvent.click="click"}(RaycasterEvent||(RaycasterEvent={}));let RaycasterService=class RaycasterService{constructor(){this.raycaster=new three_module.iMs,this.enabled=!1,this.groups=[],this.paused=!1,this.onMouseMove=this.onMouseMove.bind(this),this.onClick=this.onClick.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.subscribe()}ngOnDestroy(){this.disable(),this.unsubscribe()}subscribe(){window.addEventListener("mousemove",this.onMouseMove),window.addEventListener("click",this.onClick),window.addEventListener("touchstart",this.onTouchStart)}unsubscribe(){window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("click",this.onClick),window.removeEventListener("touchstart",this.onTouchStart)}enable(){this.enabled=!0}disable(){this.enabled=!1}pause(){this.paused=!0}resume(){this.paused=!1}get isEnabled(){return this.enabled}setCamera(camera){this.camera=camera}addGroup(group){this.groups.push(group)}onMouseMove(event){if(!this.isReady())return;const i=this.getFirstIntersectedGroup(event.layerX,event.layerY);(!i||this.selected&&this.selected===i.object)&&i||(this.selected&&(this.selected.dispatchEvent({type:RaycasterEvent.mouseExit}),this.selected=void 0),i&&i.object&&(this.selected=i.object,this.selected.dispatchEvent({type:RaycasterEvent.mouseEnter,face:i.face})))}onClick(event){if(!this.isReady(!0))return;const i=this.getFirstIntersectedGroup(event.layerX,event.layerY);i&&i.object&&i.object.dispatchEvent({type:RaycasterEvent.click,face:i.face})}onTouchStart(event){if(!this.isReady())return;const i=this.getFirstIntersectedGroup(event.touches[0].clientX,event.touches[0].clientY);i&&i.object&&i.object.dispatchEvent({type:RaycasterEvent.click,face:i.face})}isReady(ignorePaused){return this.enabled&&(ignorePaused||!this.paused)&&this.camera&&this.camera.camera&&this.groups&&this.groups.length>0}getFirstIntersectedGroup(x,y){x=x/window.innerWidth*2-1,y=-y/window.innerHeight*2+1;const mouseVector=new three_module.FM8(x,y);let face,nearestIntersection,nearestGroup;this.raycaster.setFromCamera(mouseVector,this.camera.camera);for(let k=0;k<this.groups.length;k++){const i=this.groups[k].getObject(),intersection=this.raycaster.intersectObject(i,!0);intersection.length>0&&(!nearestIntersection||nearestIntersection.distance>intersection[0].distance)&&(nearestIntersection=intersection[0],nearestIntersection.face&&(face=nearestIntersection.face),nearestGroup=i)}return nearestGroup?{object:nearestGroup,face}:void 0}static#_=this.ctorParameters=()=>[]};RaycasterService=(0,tslib_es6.gn)([(0,core.Injectable)()],RaycasterService);var renderer_canvas_componentngResource=__webpack_require__("./projects/atft/src/lib/renderer/renderer-canvas.component.scss?ngResource"),renderer_canvas_componentngResource_default=__webpack_require__.n(renderer_canvas_componentngResource);let RendererCanvasComponent=class RendererCanvasComponent{constructor(rendererService){this.rendererService=rendererService,this.preserveDrawingBuffer=!1,this.onResize=this.onResize.bind(this)}ngOnInit(){this.rendererService.initialize(this.canvas,this.preserveDrawingBuffer),this.resetCanvas()}get renderPane(){return this.canvasRef}get canvas(){return this.canvasRef.nativeElement}onResize(event){this.resetCanvas()}resetCanvas(){this.rendererService.resize(this.canvas,"100px"),this.rendererService.resize(this.canvas,"100%")}static#_=this.ctorParameters=()=>[{type:renderer_service.y}];static#_2=this.propDecorators={canvasRef:[{type:core.ViewChild,args:["canvas",{static:!0}]}],preserveDrawingBuffer:[{type:core.Input}],onResize:[{type:core.HostListener,args:["window:resize",["$event"]]}]}};RendererCanvasComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-renderer-canvas",template:"<canvas #canvas>\n  <ng-content></ng-content>\n</canvas>\n",styles:[renderer_canvas_componentngResource_default()]})],RendererCanvasComponent);let AbstractOrbitControls=class AbstractOrbitControls{constructor(rendererService,raycasterService){this.rendererService=rendererService,this.raycasterService=raycasterService}ngOnChanges(changes){this.controls&&changes.listeningControlElement&&(this.controls.dispose(),this.setUpControls())}ngOnDestroy(){this.controls&&this.controls.dispose()}configureListeners(){this.controls.addEventListener("change",(()=>{this.rendererService.render()})),this.raycasterService.isEnabled&&(this.controls.addEventListener("start",(()=>{this.raycasterService.pause()})),this.controls.addEventListener("end",(()=>{this.raycasterService.resume()})))}ngAfterViewInit(){if(void 0===this.childCameras||void 0===this.childCameras.first)throw new Error("Camera is not found");if(!this.webGlRenderer)throw new Error("webGlRenderer is not found");this.listeningControlElement=this.webGlRenderer.renderPane,this.setUpControls(),this.configureListeners(),this.rendererService.render()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:RaycasterService}];static#_2=this.propDecorators={childCameras:[{type:core.ContentChildren,args:[AbstractCamera,{descendants:!0}]}],webGlRenderer:[{type:core.ContentChild,args:[RendererCanvasComponent,{static:!1}]}],listeningControlElement:[{type:core.Input}]}};AbstractOrbitControls=(0,tslib_es6.gn)([(0,core.Directive)()],AbstractOrbitControls);let OrbitControlsComponent=class OrbitControlsComponent extends AbstractOrbitControls{constructor(rendererService,raycasterService){super(rendererService,raycasterService),this.rendererService=rendererService,this.raycasterService=raycasterService,this.rotateSpeed=1,this.zoomSpeed=1.2}setUpControls(){this.controls=new OrbitControls.z(this.childCameras.first.camera,this.listeningControlElement&&this.listeningControlElement.nativeElement),this.controls.rotateSpeed=this.rotateSpeed,this.controls.zoomSpeed=this.zoomSpeed}ngOnChanges(changes){this.controls&&(super.ngOnChanges(changes),changes.rotateSpeed&&(this.controls.rotateSpeed=this.rotateSpeed),changes.zoomSpeed&&(this.controls.zoomSpeed=this.zoomSpeed))}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:RaycasterService}];static#_2=this.propDecorators={rotateSpeed:[{type:core.Input}],zoomSpeed:[{type:core.Input}]}};OrbitControlsComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-orbit-controls",template:"\n      <ng-content></ng-content>",styles:[controls_componentngResource_default()]})],OrbitControlsComponent);var MapControls=__webpack_require__("./node_modules/three/examples/jsm/controls/MapControls.js");let MapControlsComponent=class MapControlsComponent extends AbstractOrbitControls{constructor(rendererService,raycasterService,animationService){super(rendererService,raycasterService),this.rendererService=rendererService,this.raycasterService=raycasterService,this.animationService=animationService,this.rotateSpeed=1,this.zoomSpeed=1.2,this.autoRotate=!1,this.autoRotateSpeed=.5,this.enableDamping=!1,this.dampingFactor=.1,this.screenSpacePanning=!1,this.minDistance=20,this.maxDistance=200,this.maxPolarAngle=Math.PI/2-.1,this.panSpeed=1.2,this.minZoom=0,this.maxZoom=1/0}ngOnChanges(changes){this.controls&&(super.ngOnChanges(changes),changes.rotateSpeed&&(this.controls.rotateSpeed=this.rotateSpeed),changes.zoomSpeed&&(this.controls.zoomSpeed=this.zoomSpeed))}setUpControls(){this.controls=new MapControls.o(this.childCameras.first.camera,this.listeningControlElement&&this.listeningControlElement.nativeElement),this.controls.rotateSpeed=this.rotateSpeed,this.controls.zoomSpeed=this.zoomSpeed,this.controls.panSpeed=this.panSpeed,this.controls.autoRotate=this.autoRotate,this.controls.autoRotateSpeed=this.autoRotateSpeed,this.controls.enableDamping=this.enableDamping,this.controls.dampingFactor=this.dampingFactor,this.controls.screenSpacePanning=this.screenSpacePanning,this.controls.minDistance=this.minDistance,this.controls.maxDistance=this.maxDistance,this.controls.maxPolarAngle=this.maxPolarAngle,this.controls.minZoom=this.minZoom,this.controls.maxZoom=this.maxZoom,this.controls.update(),(this.autoRotate||this.enableDamping)&&(this.animation=this.animationService.animate.subscribe((()=>{this.controls.update()})),this.controls.addEventListener("change",(()=>{this.rendererService.render()})),this.animationService.start()),this.rendererService.render()}ngOnDestroy(){super.ngOnDestroy(),this.animation?.unsubscribe()}reset(){this.controls.reset()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:RaycasterService},{type:animation_service.Y}];static#_2=this.propDecorators={rotateSpeed:[{type:core.Input}],zoomSpeed:[{type:core.Input}],autoRotate:[{type:core.Input}],autoRotateSpeed:[{type:core.Input}],enableDamping:[{type:core.Input}],dampingFactor:[{type:core.Input}],screenSpacePanning:[{type:core.Input}],minDistance:[{type:core.Input}],maxDistance:[{type:core.Input}],maxPolarAngle:[{type:core.Input}],panSpeed:[{type:core.Input}],minZoom:[{type:core.Input}],maxZoom:[{type:core.Input}]}};MapControlsComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-map-controls",template:"\n    <ng-content></ng-content>",styles:[controls_componentngResource_default()]})],MapControlsComponent);let AtftControlModule=class AtftControlModule{};AtftControlModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[OrbitControlsComponent,MapControlsComponent],imports:[common.CommonModule],exports:[OrbitControlsComponent,MapControlsComponent]})],AtftControlModule);let Deg2RadPipe=class Deg2RadPipe{transform(degrees){return degrees/180*Math.PI}};Deg2RadPipe=(0,tslib_es6.gn)([(0,core.Pipe)({name:"deg2rad"})],Deg2RadPipe);let Rad2DegPipe=class Rad2DegPipe{transform(radians){return radians*(180/Math.PI)}};Rad2DegPipe=(0,tslib_es6.gn)([(0,core.Pipe)({name:"rad2deg"})],Rad2DegPipe);let AtftPipeModule=class AtftPipeModule{};AtftPipeModule=(0,tslib_es6.gn)([(0,core.NgModule)({imports:[common.CommonModule],declarations:[Deg2RadPipe,Rad2DegPipe],exports:[Deg2RadPipe,Rad2DegPipe]})],AtftPipeModule);var RenderPass=__webpack_require__("./node_modules/three/examples/jsm/postprocessing/RenderPass.js"),UnrealBloomPass=__webpack_require__("./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"),EffectComposer=__webpack_require__("./node_modules/three/examples/jsm/postprocessing/EffectComposer.js"),ShaderPass=__webpack_require__("./node_modules/three/examples/jsm/postprocessing/ShaderPass.js"),FXAAShader=__webpack_require__("./node_modules/three/examples/jsm/shaders/FXAAShader.js");let BloomService=class BloomService{constructor(){this.materials=[],this.darkMaterial=new three_module.vBJ({color:"black"}),this.bloomLayer=new three_module.S9g,this.initialized=!1}init(renderer,scene,camera){if(renderer&&scene&&camera){this.scene=scene,this.bloomLayer.set(1);const renderScene=new RenderPass.C(scene,camera),bloomPass=new UnrealBloomPass.m(new three_module.FM8(window.innerWidth,window.innerHeight),2,.1,.1);bloomPass.clear=!0;const fxaaPass=new ShaderPass.T(FXAAShader.C),pixelRatio=renderer.getPixelRatio();fxaaPass.material.uniforms.resolution.value.x=1/(window.innerWidth*pixelRatio),fxaaPass.material.uniforms.resolution.value.y=1/(window.innerHeight*pixelRatio),this.bloomComposer=new EffectComposer.x(renderer),this.bloomComposer.renderToScreen=!1,this.bloomComposer.addPass(renderScene),this.bloomComposer.addPass(bloomPass);const finalPass=new ShaderPass.T(new three_module.jyz({uniforms:{baseTexture:{value:null},bloomTexture:{value:this.bloomComposer.renderTarget2.texture}},vertexShader:"\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }",fragmentShader:"\n  uniform sampler2D baseTexture;\n  uniform sampler2D bloomTexture;\n  varying vec2 vUv;\n  void main() {\n    gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );\n  }",defines:{}}),"baseTexture");finalPass.needsSwap=!0,this.finalComposer=new EffectComposer.x(renderer),this.finalComposer.addPass(renderScene),this.finalComposer.addPass(finalPass),this.finalComposer.addPass(fxaaPass),this.initialized=!0}else console.warn("BloomService.init not all parameters settled")}render(){this.initialized&&(this.scene.traverse((i=>{this.darkenNonBloomed(i)})),this.bloomComposer.render(),this.scene.traverse((i=>{this.restoreMaterial(i)})),this.finalComposer.render())}darkenNonBloomed(obj){this.initialized&&obj.isMesh&&!1===this.bloomLayer.test(obj.layers)&&(this.materials[obj.uuid]=obj.material,obj.material=this.darkMaterial)}restoreMaterial(obj){this.initialized&&obj.isMesh&&this.materials[obj.uuid]&&(obj.material=this.materials[obj.uuid],delete this.materials[obj.uuid])}};BloomService=(0,tslib_es6.gn)([(0,core.Injectable)()],BloomService);let AtftRendererModule=class AtftRendererModule{};AtftRendererModule=(0,tslib_es6.gn)([(0,core.NgModule)({imports:[common.CommonModule],declarations:[RendererCanvasComponent],providers:[renderer_service.y,BloomService],exports:[RendererCanvasComponent]})],AtftRendererModule);let EmitStepComponent=class EmitStepComponent{constructor(){this.action=new core.EventEmitter,console.log("EmitStepComponent.constructor")}ngAfterViewInit(){console.log("EmitStepComponent.ngAfterViewInit")}ngOnDestroy(){console.log("EmitStepComponent.ngOnDestroy")}ngOnChanges(changes){console.log("EmitStepComponent.ngOnChanges",changes)}static#_=this.ctorParameters=()=>[];static#_2=this.propDecorators={ms:[{type:core.Input}],action:[{type:core.Output}]}};EmitStepComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-emit-step",providers:[(0,provide_parent.T)(EmitStepComponent)],template:"<ng-content></ng-content>"})],EmitStepComponent);let TimelineEmitterComponent=class TimelineEmitterComponent{constructor(){this.autostart=!1,console.log("TimelineEmitterComponent.constructor")}ngAfterViewInit(){console.log("TimelineEmitterComponent.ngAfterViewInit",this.emitSteps),this.autostart&&this.start()}ngOnDestroy(){console.log("TimelineEmitterComponent.ngOnDestroy")}ngOnChanges(changes){console.log("TimelineEmitterComponent.ngOnChanges",changes)}ngOnInit(){console.log("TimelineEmitterComponent.ngOnInit",this.emitSteps)}start(){console.log("TimelineEmitterComponent.start"),this.emitSteps?.forEach((i=>{console.log("TimelineEmitterComponent.start setTimeout on",i.ms),setTimeout((()=>{i.action.emit()}),i.ms)}))}static#_=this.ctorParameters=()=>[];static#_2=this.propDecorators={emitSteps:[{type:core.ContentChildren,args:[EmitStepComponent,{descendants:!0}]}],autostart:[{type:core.Input}]}};TimelineEmitterComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-timeline-emitter",template:"<ng-content></ng-content>"})],TimelineEmitterComponent);let AtftAnimationModule=class AtftAnimationModule{};AtftAnimationModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[TimelineEmitterComponent,EmitStepComponent],providers:[animation_service.Y],exports:[TimelineEmitterComponent,EmitStepComponent]})],AtftAnimationModule);let RaycasterGroupDirective=class RaycasterGroupDirective{constructor(host,raycasterService){this.host=host,this.raycasterService=raycasterService,this.mouseEnter=new core.EventEmitter,this.mouseExit=new core.EventEmitter,this.click=new core.EventEmitter,this.onMouseEnter=this.onMouseEnter.bind(this),this.onMouseExit=this.onMouseExit.bind(this),this.onClick=this.onClick.bind(this)}ngAfterViewInit(){this.raycasterService.addGroup(this.host),this.subscribeEvents()}subscribeEvents(){const obj=this.host.getObject();obj.addEventListener(RaycasterEvent.mouseEnter,this.onMouseEnter),obj.addEventListener(RaycasterEvent.mouseExit,this.onMouseExit),obj.addEventListener(RaycasterEvent.click,this.onClick)}unSubscribeEvents(){const obj=this.host.getObject();obj&&(obj.removeEventListener(RaycasterEvent.mouseEnter,this.onMouseEnter),obj.removeEventListener(RaycasterEvent.mouseExit,this.onMouseExit),obj.removeEventListener(RaycasterEvent.click,this.onClick))}onMouseExit(){this.mouseExit.emit({component:this.host})}onMouseEnter(event){this.mouseEnter.emit({component:this.host,face:event.face})}onClick(event){this.click.emit({component:this.host,face:event.face})}ngOnDestroy(){this.unSubscribeEvents()}static#_=this.ctorParameters=()=>[{type:abstract_object_3d.l},{type:RaycasterService}];static#_2=this.propDecorators={mouseEnter:[{type:core.Output}],mouseExit:[{type:core.Output}],click:[{type:core.Output}]}};RaycasterGroupDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[atft-raycaster-group]"})],RaycasterGroupDirective);let RaycasterCameraDirective=class RaycasterCameraDirective{constructor(host,raycasterService){this.host=host,this.raycasterService=raycasterService}ngAfterViewInit(){this.raycasterService.setCamera(this.host)}static#_=this.ctorParameters=()=>[{type:AbstractCamera},{type:RaycasterService}]};RaycasterCameraDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[atft-raycaster-camera]"})],RaycasterCameraDirective);let RaycasterEnableDirective=class RaycasterEnableDirective{constructor(raycasterService){this.raycasterService=raycasterService}ngAfterViewInit(){this.raycasterService.enable()}static#_=this.ctorParameters=()=>[{type:RaycasterService}]};RaycasterEnableDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[atft-raycaster-enable]"})],RaycasterEnableDirective);let AtftRaycasterModule=class AtftRaycasterModule{};AtftRaycasterModule=(0,tslib_es6.gn)([(0,core.NgModule)({imports:[common.CommonModule],declarations:[RaycasterGroupDirective,RaycasterCameraDirective,RaycasterEnableDirective],providers:[RaycasterService],exports:[RaycasterGroupDirective,RaycasterCameraDirective,RaycasterEnableDirective]})],AtftRaycasterModule);var stats_service=__webpack_require__("./projects/atft/src/lib/stats/stats.service.ts");let StatsAutoShowDirective=class StatsAutoShowDirective{constructor(statsService){this.statsService=statsService}ngAfterViewInit(){this.statsService.create()}static#_=this.ctorParameters=()=>[{type:stats_service.G}]};StatsAutoShowDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[atft-stats-auto-show]"})],StatsAutoShowDirective);let AtftStatsModule=class AtftStatsModule{};AtftStatsModule=(0,tslib_es6.gn)([(0,core.NgModule)({imports:[common.CommonModule],providers:[stats_service.G],declarations:[StatsAutoShowDirective],exports:[StatsAutoShowDirective]})],AtftStatsModule);let DashedDrawDirective=class DashedDrawDirective{constructor(host,animationService){this.host=host,this.animationService=animationService,this.dashColor="#FF0000",this.dashIncrement=10,this.hideDash=!1,this.stop=!1}ngAfterViewInit(){this.tryToFindGeometry(),this.animate=this.animate.bind(this),this.animation=this.animationService.animate.subscribe(this.animate),this.animationService.start()}tryToFindGeometry(){this.host.getObject().traverse((child=>{const findMesh=child instanceof three_module.Kj0?child:child.children[0];if(findMesh&&findMesh instanceof three_module.Kj0&&!this.edges){const edgesGeom=new three_module.TOt(findMesh.geometry,8);this.edges=new three_module.ejS(edgesGeom,new three_module.FT0({color:this.dashColor})),this.edges.computeLineDistances(),this.edges.material.dashSize=0,this.edges.material.gapSize=this.edges.geometry.attributes.lineDistance.array[this.edges.geometry.attributes.lineDistance.count-1],this.material=findMesh.material,console.log("DashedDrawDirective.tryToFindGeometry original material",this.material),this.initialOpacity>=0&&(this.material.transparent||(this.material.transparent=!0,this.material.depthWrite=!0,this.material.needsUpdate=!0),this.material.opacity=this.initialOpacity),findMesh.add(this.edges)}}))}animate(){this.stop||(this.edges?(this.edges.material.dashSize+=this.dashIncrement,this.edges.material.dashSize>=this.edges.material.gapSize&&(this.hideDash&&(this.edges.parent.children=[]),this.targetOpacity>=0&&(this.material.opacity=this.targetOpacity,1===this.targetOpacity&&(this.material.transparent=!1)),this.stop=!0)):this.tryToFindGeometry())}ngOnDestroy(){this.animation?.unsubscribe()}static#_=this.ctorParameters=()=>[{type:abstract_object_3d.l},{type:animation_service.Y}];static#_2=this.propDecorators={dashColor:[{type:core.Input}],dashIncrement:[{type:core.Input}],initialOpacity:[{type:core.Input}],targetOpacity:[{type:core.Input}],hideDash:[{type:core.Input}]}};DashedDrawDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[atft-dashed-draw]"})],DashedDrawDirective);let FogComponent=class FogComponent{constructor(rendererService,parent){this.rendererService=rendererService,this.parent=parent,this.color="#0000AA",this.near=10,this.far=100}ngAfterViewInit(){this.parent&&this.parent.getObject()&&this.parent.getObject().isScene&&(this.scene=this.parent.getObject(),this.enableFog())}enableFog(){this.scene.fog=new three_module.ybr(this.color,this.near,this.far),this.rendererService.render()}disableFog(){this.scene.fog=null,this.rendererService.render()}ngOnDestroy(){this.disableFog()}ngOnChanges(changes){this.scene&&["color","near","far"].some((propName=>propName in changes))&&this.enableFog()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:SceneComponent,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={color:[{type:core.Input}],near:[{type:core.Input}],far:[{type:core.Input}]}};FogComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-fog",template:""})],FogComponent);var BokehPass=__webpack_require__("./node_modules/three/examples/jsm/postprocessing/BokehPass.js");let EffectComposerComponent=class EffectComposerComponent{constructor(rendererService,parentScene){this.rendererService=rendererService,this.parentScene=parentScene,this.renderToScreen=!0}ngAfterViewInit(){this.initComposer()}ngOnDestroy(){this.rendererService.setComposer(void 0),this.composer=void 0,this.rendererService.render()}initComposer(){if(!this.composer&&this.rendererService.getWebGlRenderer()){this.composer=new EffectComposer.x(this.rendererService.getWebGlRenderer()),this.composer.renderToScreen=this.renderToScreen;const renderPass=new RenderPass.C(this.parentScene.getObject(),this.rendererService.getCamera().camera);this.addPass(renderPass),this.sceneBackgroundTarget&&(this.sceneBackgroundTarget.getObject().background=this.composer.writeBuffer.texture),this.rendererService.setComposer(this)}}addPass(pass){this.initComposer(),this.composer?.addPass(pass)}removePass(pass){if(this.composer&&this.composer.passes.length>1){const passes=this.composer.passes,index=passes.indexOf(pass,0);index>-1&&passes.splice(index,1),1===passes.length&&(this.composer=void 0)}}render(){this.composer&&this.composer.render(.1)}getComposer(){return this.composer}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:SceneComponent,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={renderToScreen:[{type:core.Input}],sceneBackgroundTarget:[{type:core.Input}]}};EffectComposerComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-effect-composer",template:""})],EffectComposerComponent);let AbstractComposeEffect=class AbstractComposeEffect{constructor(rendererService,composer){this.rendererService=rendererService,this.composer=composer,this.pass=[]}enable(){this.composer&&(this.initPasses(),this.pass.forEach((pass=>this.composer.addPass(pass))),this.rendererService.render())}disable(){this.composer&&(this.pass.forEach((pass=>this.composer.removePass(pass))),this.rendererService.render())}ngAfterViewInit(){this.enable()}ngOnDestroy(){this.disable()}ngOnChanges(changes){this.pass&&this.applyChanges(changes)&&this.rendererService.render()}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:EffectComposerComponent,decorators:[{type:core.SkipSelf},{type:core.Optional}]}]};AbstractComposeEffect=(0,tslib_es6.gn)([(0,core.Directive)()],AbstractComposeEffect);let DofComponent=class DofComponent extends AbstractComposeEffect{constructor(rendererService,composer){super(rendererService,composer),this.rendererService=rendererService,this.composer=composer,this.focus=1,this.aperture=.025,this.maxblur=.01}applyChanges(changes){let modified=!1;return this.pass[0]&&(["focus"].some((propName=>propName in changes))&&(this.pass[0].uniforms.focus.value=this.focus,modified=!0),["aperture"].some((propName=>propName in changes))&&(this.pass[0].uniforms.aperture.value=this.aperture,modified=!0),["maxblur"].some((propName=>propName in changes))&&(this.pass[0].uniforms.maxblur.value=this.maxblur,modified=!0)),modified}initPasses(){this.pass.push(new BokehPass.A(this.rendererService.getScene().getObject(),this.rendererService.getCamera().camera,{focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,aspect:window.innerWidth/window.innerHeight}))}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:EffectComposerComponent,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={focus:[{type:core.Input}],aperture:[{type:core.Input}],maxblur:[{type:core.Input}]}};DofComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-dof",template:""})],DofComponent);var DotScreenShader=__webpack_require__("./node_modules/three/examples/jsm/shaders/DotScreenShader.js");let DotScreenComponent=class DotScreenComponent extends AbstractComposeEffect{constructor(rendererService,composer){super(rendererService,composer),this.rendererService=rendererService,this.composer=composer,this.scale=4}initPasses(){this.pass.push(new ShaderPass.T(DotScreenShader.a))}applyChanges(changes){return!1}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:EffectComposerComponent,decorators:[{type:core.SkipSelf},{type:core.Optional}]}];static#_2=this.propDecorators={scale:[{type:core.Input}]}};DotScreenComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-dot-screen",template:""})],DotScreenComponent);var VerticalBlurShader=__webpack_require__("./node_modules/three/examples/jsm/shaders/VerticalBlurShader.js"),HorizontalBlurShader=__webpack_require__("./node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js");let BlurComponent=class BlurComponent extends AbstractComposeEffect{constructor(rendererService,composer){super(rendererService,composer),this.rendererService=rendererService,this.composer=composer}initPasses(){this.pass.push(new ShaderPass.T(VerticalBlurShader.Z)),this.pass.push(new ShaderPass.T(HorizontalBlurShader.P)),this.pass.push(new ShaderPass.T(VerticalBlurShader.Z)),this.pass.push(new ShaderPass.T(HorizontalBlurShader.P))}applyChanges(changes){return!1}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:EffectComposerComponent,decorators:[{type:core.SkipSelf},{type:core.Optional}]}]};BlurComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-blur",template:""})],BlurComponent);let AtftEffectModule=class AtftEffectModule{};AtftEffectModule=(0,tslib_es6.gn)([(0,core.NgModule)({imports:[common.CommonModule],declarations:[DashedDrawDirective,FogComponent,DofComponent,DotScreenComponent,EffectComposerComponent,BlurComponent],exports:[DashedDrawDirective,FogComponent,DofComponent,DotScreenComponent,EffectComposerComponent,BlurComponent]})],AtftEffectModule);let AtftModule=class AtftModule{};AtftModule=(0,tslib_es6.gn)([(0,core.NgModule)({imports:[AtftCameraModule,AtftObjectModule,AtftControlModule,AtftPipeModule,AtftRendererModule,AtftAnimationModule,AtftRaycasterModule,AtftStatsModule,AtftEffectModule],exports:[AtftCameraModule,AtftObjectModule,AtftControlModule,AtftPipeModule,AtftRendererModule,AtftAnimationModule,AtftRaycasterModule,AtftStatsModule,AtftEffectModule]})],AtftModule)},"./projects/atft/src/lib/object/abstract-object-3d.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{l:()=>AbstractObject3D});var tslib__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./projects/atft/src/lib/renderer/renderer.service.ts"),uuid__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/uuid/dist/esm-browser/v4.js");let AbstractObject3D=class AbstractObject3D{constructor(rendererService,parent){this.rendererService=rendererService,this.parent=parent,this.scaleX=1,this.scaleY=1,this.scaleZ=1,this.name=(0,uuid__WEBPACK_IMPORTED_MODULE_0__.Z)(),this.layer=0,this.changed=new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter,this.childlren=[]}ngOnChanges(changes){if(!this.object)return;let modified=!1;["rotateX","rotateY","rotateZ"].some((propName=>propName in changes))&&(this.applyRotation(),modified=!0),["translateX","translateY","translateZ"].some((propName=>propName in changes))&&(this.applyTranslation(),modified=!0),["scaleX","scaleY","scaleZ"].some((propName=>propName in changes))&&(this.applyScale(),modified=!0),modified&&(this.changed.emit(),this.rendererService.render())}ngOnDestroy(){this.object&&this.object.parent&&(this.parent.removeChild(this),this.rendererService&&this.rendererService.render())}ngOnInit(){this.object=this.newObject3DInstance(),this.layer&&this.object.layers.set(this.layer),this.applyTranslation(),this.applyRotation(),this.applyScale(),this.afterInit()}updateParent(){this.parent&&(this.parent.addChild(this),this.rendererService.render())}applyRotation(){this.object.rotation.set(this.rotateX||0,this.rotateY||0,this.rotateZ||0,"XYZ")}applyTranslation(){this.object.position.set(this.translateX||0,this.translateY||0,this.translateZ||0)}applyScale(){this.object.scale.set(this.scaleX||0,this.scaleY||0,this.scaleZ||0)}addChild(object){this.object&&(this.childlren.push(object),this.object.add(object.getObject()),this.rendererService&&this.rendererService.render())}afterInit(){}removeChild(object){if(this.object&&object){const index=this.childlren.indexOf(object,0);index>-1&&this.childlren.splice(index,1),this.object.remove(object.getObject())}}getObject(){return this.object}ngAfterViewInit(){this.updateParent()}findByName(name){return this.recursionByName(this,name)}recursionByName(currentNode,name){if(currentNode.object&&currentNode.name===name)return currentNode;let node;return currentNode.childlren.some((child=>node=this.recursionByName(child,name))),node}getChildren(){return this.childlren}removeChildByName(name){this.childlren=this.childlren.filter((i=>i.name!==name))}static#_=this.ctorParameters=()=>[{type:_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_2__.y},{type:AbstractObject3D,decorators:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.SkipSelf},{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional}]}];static#_2=this.propDecorators={rotateX:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],rotateY:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],rotateZ:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],translateX:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],translateY:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],translateZ:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],scaleX:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],scaleY:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],scaleZ:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],name:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],layer:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],changed:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output}]}};AbstractObject3D=(0,tslib__WEBPACK_IMPORTED_MODULE_3__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive)()],AbstractObject3D)},"./projects/atft/src/lib/object/connector/line-connector.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{J:()=>LineConnectorComponent});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),three_module=__webpack_require__("./node_modules/three/build/three.module.js"),animation_service=__webpack_require__("./projects/atft/src/lib/animation/animation.service.ts"),renderer_service=__webpack_require__("./projects/atft/src/lib/renderer/renderer.service.ts"),provide_parent=__webpack_require__("./projects/atft/src/lib/util/provide-parent.ts"),abstract_object_3d=__webpack_require__("./projects/atft/src/lib/object/abstract-object-3d.ts");let AbstractConnector=class AbstractConnector extends abstract_object_3d.l{newObject3DInstance(){const line=this.createLineMesh();return this.source&&this.target&&this.watchObjects(),line}watchObjects(){this.sourceSub=this.source.changed.subscribe((()=>{this.updateLineGeometry()})),this.targetSub=this.target.changed.subscribe((()=>{this.updateLineGeometry()}))}ngOnDestroy(){super.ngOnDestroy(),this.sourceSub?.unsubscribe(),this.targetSub?.unsubscribe()}static#_=this.propDecorators={source:[{type:core.Input}],target:[{type:core.Input}]}};AbstractConnector=(0,tslib_es6.gn)([(0,core.Directive)()],AbstractConnector);var LineType,Line2=__webpack_require__("./node_modules/three/examples/jsm/lines/Line2.js"),LineGeometry=__webpack_require__("./node_modules/three/examples/jsm/lines/LineGeometry.js"),LineMaterial=__webpack_require__("./node_modules/three/examples/jsm/lines/LineMaterial.js");!function(LineType){LineType.dashed="dash",LineType.solid="solid"}(LineType||(LineType={}));let LineConnectorComponent=class LineConnectorComponent extends AbstractConnector{constructor(rendererService,parent,animationService){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.animationService=animationService,this.materialColor=16777215,this.solid=!1,this.lineWidth=2,this.dashSize=3,this.gapSize=.5,this.opacity=1,this.lineType=LineType.dashed,this.animated=!0,this.time=0,this.timeScale=5,this.clock=new three_module.SUY}createLineMesh(){const positions=this.getPositions(),geometry=new LineGeometry.L;return geometry.setPositions(positions),this.matLine=new LineMaterial.Y({color:this.materialColor,linewidth:this.lineWidth,vertexColors:!1,dashed:!this.solid,dashSize:this.dashSize,dashOffset:0,gapSize:this.gapSize,opacity:this.opacity,transparent:this.opacity<1,depthWrite:!0}),this.matLine.resolution.set(window.innerWidth,window.innerHeight),this.solid||(this.matLine.defines.USE_DASH=""),this.line=new Line2.w(geometry,this.matLine),this.line.computeLineDistances(),this.animated&&(this.animate=this.animate.bind(this),this.animation=this.animationService.animate.subscribe(this.animate)),this.line}updateLineGeometry(){const positions=this.getPositions();this.line.geometry.dispose(),this.line.geometry.setPositions(positions),this.line.computeLineDistances()}getPositions(){if(!this.source||!this.target)throw new Error("AbstractConnector: source or target inputs are missing!");const source=this.source.getObject().position,target=this.target.getObject().position,positions=[];return positions.push(source.x,source.y,source.z),positions.push(target.x,target.y,target.z),positions}ngOnDestroy(){super.ngOnDestroy(),this.animation&&this.animation.unsubscribe()}animate(){const material=this.line?.material;this.line?.material&&(this.time+=this.clock.getDelta(),material.dashOffset=-1*this.time*this.timeScale,this.line.computeLineDistances())}ngOnChanges(changes){if(!this.object)return;super.ngOnChanges(changes);let modified=!1;["materialColor"].some((propName=>propName in changes))&&(console.log("Changed color to",this.materialColor),this.line.material.color=new three_module.Ilk(this.materialColor),this.line.material.needsUpdate=!0,modified=!0),modified&&(this.changed.emit(),this.rendererService.render())}static#_=this.ctorParameters=()=>[{type:renderer_service.y},{type:abstract_object_3d.l,decorators:[{type:core.SkipSelf},{type:core.Optional}]},{type:animation_service.Y}];static#_2=this.propDecorators={materialColor:[{type:core.Input}],solid:[{type:core.Input}],lineWidth:[{type:core.Input}],dashSize:[{type:core.Input}],gapSize:[{type:core.Input}],opacity:[{type:core.Input}],lineType:[{type:core.Input}],animated:[{type:core.Input}]}};LineConnectorComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"atft-line-connector",providers:[(0,provide_parent.T)(LineConnectorComponent)],template:"<ng-content></ng-content>"})],LineConnectorComponent)},"./projects/atft/src/lib/object/content-projection.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{H:()=>ContentProjectionComponent});var tslib__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),_helper_empty_component__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./projects/atft/src/lib/object/helper/empty.component.ts"),_abstract_object_3d__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./projects/atft/src/lib/object/abstract-object-3d.ts"),_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./projects/atft/src/lib/renderer/renderer.service.ts"),_util__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./projects/atft/src/lib/util/provide-parent.ts");let ContentProjectionComponent=class ContentProjectionComponent extends _helper_empty_component__WEBPACK_IMPORTED_MODULE_0__.T{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent}addChild(object){this.contentProjection?this.contentProjection.addChild(object):console.error('ContentProjectionComponent error: #contentProjection name not found! Embedded child object in "ng-content" can not be attached to parentScene object')}static#_=this.ctorParameters=()=>[{type:_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_1__.y},{type:_abstract_object_3d__WEBPACK_IMPORTED_MODULE_2__.l,decorators:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_3__.SkipSelf},{type:_angular_core__WEBPACK_IMPORTED_MODULE_3__.Optional}]}];static#_2=this.propDecorators={contentProjection:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_3__.ViewChild,args:["contentProjection"]}]}};ContentProjectionComponent=(0,tslib__WEBPACK_IMPORTED_MODULE_4__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.Component)({selector:"atft-content-projection",providers:[(0,_util__WEBPACK_IMPORTED_MODULE_5__.T)(ContentProjectionComponent)],template:"<ng-content></ng-content>"})],ContentProjectionComponent)},"./projects/atft/src/lib/object/helper/empty.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{T:()=>EmptyComponent});var tslib__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),three__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/three/build/three.module.js"),_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./projects/atft/src/lib/renderer/renderer.service.ts"),_util__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./projects/atft/src/lib/util/provide-parent.ts"),_abstract_object_3d__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./projects/atft/src/lib/object/abstract-object-3d.ts");let EmptyComponent=class EmptyComponent extends _abstract_object_3d__WEBPACK_IMPORTED_MODULE_0__.l{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent}newObject3DInstance(){return new three__WEBPACK_IMPORTED_MODULE_1__.Tme}static#_=this.ctorParameters=()=>[{type:_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_2__.y},{type:_abstract_object_3d__WEBPACK_IMPORTED_MODULE_0__.l,decorators:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_3__.SkipSelf},{type:_angular_core__WEBPACK_IMPORTED_MODULE_3__.Optional}]}]};EmptyComponent=(0,tslib__WEBPACK_IMPORTED_MODULE_4__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.Component)({selector:"atft-empty",providers:[(0,_util__WEBPACK_IMPORTED_MODULE_5__.T)(EmptyComponent)],template:"<ng-content></ng-content>"})],EmptyComponent)},"./projects/atft/src/lib/object/loader/services/abstract-asset.service.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{b:()=>AbstractAssetService});var tslib__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs");let AbstractAssetService=class AbstractAssetService{constructor(){this.providers=new Map,this.init()}registerProvider(key,source){this.providers.set(key,source)}setDefaultProvider(key){this.defaultProvider=key}getSource(icon){if(icon){if(icon.indexOf(":")>0){const args=icon.split(":");return this.getSourceByNamespace(args[0],args[1])}return this.getSourceByNamespace(this.defaultProvider,icon)}return this.defaultIfNotFound(icon)}getSourceByNamespace(namespace,icon){const provider=this.providers.get(namespace);if(!provider)return console.warn("Icon provider not found",provider),this.defaultIfNotFound(icon);const finalUrl=provider.url.replace("?",icon);return this.getFinalResult(finalUrl,provider)}static#_=this.ctorParameters=()=>[]};AbstractAssetService=(0,tslib__WEBPACK_IMPORTED_MODULE_0__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable)()],AbstractAssetService)},"./projects/atft/src/lib/object/loader/services/model.service.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{b:()=>ModelService});var tslib__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),_abstract_asset_service__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./projects/atft/src/lib/object/loader/services/abstract-asset.service.ts");let ModelService=class ModelService extends _abstract_asset_service__WEBPACK_IMPORTED_MODULE_0__.b{constructor(){super(...arguments),this.defaultProvider="3d"}init(){this.registerProvider("3d",{url:"https://raw.githubusercontent.com/makimenko/files/master/actor-models/?.obj"})}defaultIfNotFound(icon){return{url:icon}}getFinalResult(finalUrl,provider){return{url:finalUrl}}};ModelService=(0,tslib__WEBPACK_IMPORTED_MODULE_1__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable)()],ModelService)},"./projects/atft/src/lib/object/mesh/abstract-mesh-3d.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{x:()=>AbstractMesh});var tslib__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),_abstract_object_3d__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./projects/atft/src/lib/object/abstract-object-3d.ts"),_util__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./projects/atft/src/lib/util/applied-material.ts");let AbstractMesh=class AbstractMesh extends _abstract_object_3d__WEBPACK_IMPORTED_MODULE_0__.l{constructor(){super(...arguments),this.materialColor="#5DADE2",this.castShadow=!0,this.receiveShadow=!0,this.depthWrite=!0}getMaterial(){return(0,_util__WEBPACK_IMPORTED_MODULE_1__.m)(this.materialColor,this.material,this.depthWrite)}applyShadowProps(mesh){mesh.castShadow=this.castShadow,mesh.receiveShadow=this.receiveShadow}ngOnChanges(changes){if(super.ngOnChanges(changes),!this.getObject())return;let mustRerender=!1;["material","materialColor","depthWrite"].some((propName=>propName in changes))&&(this.applyMaterial(),mustRerender=!0),mustRerender&&this.rendererService.render()}applyMaterial(){this.getObject().material=this.getMaterial()}static#_=this.propDecorators={material:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_2__.Input}],materialColor:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_2__.Input}],castShadow:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_2__.Input}],receiveShadow:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_2__.Input}],depthWrite:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_2__.Input}]}};AbstractMesh=(0,tslib__WEBPACK_IMPORTED_MODULE_3__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive)()],AbstractMesh)},"./projects/atft/src/lib/object/mesh/box-mesh.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{T:()=>BoxMeshComponent});var tslib__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),three__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/three/build/three.module.js"),_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./projects/atft/src/lib/renderer/renderer.service.ts"),_util__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__("./projects/atft/src/lib/util/provide-parent.ts"),_abstract_object_3d__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./projects/atft/src/lib/object/abstract-object-3d.ts"),_abstract_mesh_3d__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./projects/atft/src/lib/object/mesh/abstract-mesh-3d.ts");let BoxMeshComponent=class BoxMeshComponent extends _abstract_mesh_3d__WEBPACK_IMPORTED_MODULE_0__.x{constructor(rendererService,parent){super(rendererService,parent),this.rendererService=rendererService,this.parent=parent,this.width=1,this.height=1,this.depth=1,this.widthSegments=1,this.heightSegments=1,this.depthSegments=1}newObject3DInstance(){const geometry=new three__WEBPACK_IMPORTED_MODULE_1__.DvJ(this.width,this.height,this.depth,this.widthSegments,this.heightSegments,this.depthSegments),material=this.getMaterial(),mesh=new three__WEBPACK_IMPORTED_MODULE_1__.Kj0(geometry,material);return this.applyShadowProps(mesh),mesh}static#_=this.ctorParameters=()=>[{type:_renderer_renderer_service__WEBPACK_IMPORTED_MODULE_2__.y},{type:_abstract_object_3d__WEBPACK_IMPORTED_MODULE_3__.l,decorators:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_4__.SkipSelf},{type:_angular_core__WEBPACK_IMPORTED_MODULE_4__.Optional}]}];static#_2=this.propDecorators={width:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_4__.Input}],height:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_4__.Input}],depth:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_4__.Input}],widthSegments:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_4__.Input}],heightSegments:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_4__.Input}],depthSegments:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_4__.Input}]}};BoxMeshComponent=(0,tslib__WEBPACK_IMPORTED_MODULE_5__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_4__.Component)({selector:"atft-box-mesh",providers:[(0,_util__WEBPACK_IMPORTED_MODULE_6__.T)(BoxMeshComponent)],template:"<ng-content></ng-content>"})],BoxMeshComponent)},"./projects/atft/src/lib/renderer/renderer.service.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{y:()=>RendererService});var tslib__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),three__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/three/build/three.module.js"),_stats_stats_service__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./projects/atft/src/lib/stats/stats.service.ts");let RendererService=class RendererService{constructor(statsService){this.statsService=statsService,this.init=!1}setScene(scene){this.scene=scene}setCamera(camera){this.camera=camera,this.camera.updateAspectRatio(this.aspect)}render(){this.init&&this.scene&&this.scene.getObject()&&this.camera&&this.camera.camera&&(this.composer?(this.composer.render(),this.composer.renderToScreen||this.webGlRenderer.render(this.scene.getObject(),this.camera.camera)):this.webGlRenderer.render(this.scene.getObject(),this.camera.camera),this.statsService.update())}initialize(canvas,preserveDrawingBuffer){this.webGlRenderer=new three__WEBPACK_IMPORTED_MODULE_0__.CP7({canvas,antialias:!0,alpha:!0,preserveDrawingBuffer}),this.webGlRenderer.setPixelRatio(window.devicePixelRatio),this.webGlRenderer.setSize(canvas.clientWidth,canvas.clientHeight,!0),this.webGlRenderer.shadowMap.enabled=!1,this.webGlRenderer.shadowMap.autoUpdate=!1,this.webGlRenderer.shadowMap.type=three__WEBPACK_IMPORTED_MODULE_0__.ntZ,this.webGlRenderer.setClearColor(0,0),this.webGlRenderer.autoClear=!0,canvas.style.zIndex="2",this.updateChildCamerasAspectRatio(canvas),this.init=!0,this.render()}resize(canvas,size){canvas.style.width=size,canvas.style.height=size,canvas.style.border="none";const width=canvas.clientWidth,height=canvas.clientHeight;this.webGlRenderer.setSize(width,height,!0),this.updateChildCamerasAspectRatio(canvas),this.render()}updateAspectRatio(canvas){0!==canvas.clientHeight&&(this.aspect=canvas.clientWidth/canvas.clientHeight)}updateChildCamerasAspectRatio(canvas){this.updateAspectRatio(canvas),this.camera&&this.camera.updateAspectRatio(this.aspect)}getScene(){return this.scene}getCamera(){return this.camera}getWebGlRenderer(){return this.webGlRenderer}setComposer(composer){this.composer=composer}static#_=this.ctorParameters=()=>[{type:_stats_stats_service__WEBPACK_IMPORTED_MODULE_1__.G}]};RendererService=(0,tslib__WEBPACK_IMPORTED_MODULE_2__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable)()],RendererService)},"./projects/atft/src/lib/stats/stats.service.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{G:()=>StatsService});var tslib__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),three_examples_jsm_libs_stats_module_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/three/examples/jsm/libs/stats.module.js");let StatsService=class StatsService{constructor(){document.body.addEventListener("keydown",(event=>{event.altKey&&"s"===event.key&&this.toggle()}))}update(){this.stats&&this.stats.update()}toggle(){this.stats?this.remove():this.create()}create(){this.stats||(this.stats=new three_examples_jsm_libs_stats_module_js__WEBPACK_IMPORTED_MODULE_0__.Z,document.body.appendChild(this.stats.dom))}remove(){this.stats&&(this.stats.dom.remove(),this.stats.dom=void 0,this.stats=void 0)}ngOnDestroy(){this.remove()}static#_=this.ctorParameters=()=>[]};StatsService=(0,tslib__WEBPACK_IMPORTED_MODULE_1__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable)()],StatsService)},"./projects/atft/src/lib/util/applied-material.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{m:()=>appliedMaterial});var three__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/three/build/three.module.js");function appliedMaterial(materialColor,materialName,depthWrite){const props={color:materialColor instanceof three__WEBPACK_IMPORTED_MODULE_0__.Ilk?materialColor:new three__WEBPACK_IMPORTED_MODULE_0__.Ilk(materialColor),side:three__WEBPACK_IMPORTED_MODULE_0__.ehD,depthWrite:void 0===depthWrite||depthWrite};return"lamb"===materialName?new three__WEBPACK_IMPORTED_MODULE_0__.YBo(props):"basic"===materialName?new three__WEBPACK_IMPORTED_MODULE_0__.vBJ(props):new three__WEBPACK_IMPORTED_MODULE_0__.xoR(props)}},"./projects/atft/src/lib/util/provide-parent.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{T:()=>provideParent});var _angular_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),_object_abstract_object_3d__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./projects/atft/src/lib/object/abstract-object-3d.ts");function provideParent(component,parentType){return{provide:parentType||_object_abstract_object_3d__WEBPACK_IMPORTED_MODULE_0__.l,useExisting:(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((()=>component))}}},"./projects/atft/src/lib/control/controls.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  display: flex;\n  flex: 1;\n  height: 100%;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/atft/src/lib/renderer/renderer-canvas.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  display: flex;\n  flex: 1;\n  height: 100%;\n}\n\ncanvas {\n  flex: 1;\n  outline: none;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()}}]);